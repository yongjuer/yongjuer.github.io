<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="记录生活，分享技术，分享生活。">
    <meta name="author" content="小举">
    
    <title>
        
            深入学习 JavaScript 系列（二)：This 关键字 |
        
        小举的阿勒泰
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.png">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/regular.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/solid.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/brands.min.css">
    
        
            
                
<link rel="stylesheet" href="/css/custom.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"yongjuer.site","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"base_info":{"primary_color":"rgba(211, 84, 0,1.0)","title":"小举的阿勒泰","author":"小举","avatar":"/images/avatar.png","logo":"/images/avatar.png","favicon":"/images/logo.png"},"menu":{"home":"/ || fa-solid fa-home","archives":"/archives || fa-solid fa-box-archive","tags":"/tags || fa-solid fa-tags","categories":"/categories || fa-solid fa-layer-group","tools":"/tools || fa-solid fa-tools"},"first_screen":{"enable":true,"background_img":"/images/background.jpg","background_img_dark":"/images/background.jpg","description":null,"hitokoto":true},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":true,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"created"},"post":{"author_badge":{"enable":true,"level_badge":false,"custom_badge":["炼气","筑基","结丹","元婴","化神"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD","copyright_info":true,"share":true,"reward":{"enable":false,"img_link":null,"text":null},"updated_datetime_icon":"fa-solid fa-arrows-rotate","created_datetime_icon":"fa-solid fa-feather"},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":3},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2021,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":true,"css":[["/css/custom.css"]],"js":[null]},"root":"","source_data":{"tools":[{"category":"聊天 AI","anchorId":"JUU4JTgxJThBJUU1JUE0JUE5JTIwQUk0"},{"name":"ChatGPT","link":"https://chat.openai.com/","description":"OpenAI 旗下 AI 聊天对话工具","image":"/images/tools/chatgpt.svg"},{"name":"Gemini","link":"https://gemini.google.com/app","description":"Google 旗下 AI 聊天对话工具","image":"/images/tools/gemini.svg"},{"name":"Copilot","link":"https://copilot.microsoft.com/","description":"微软旗下的日常 AI 助手","image":"/images/tools/copilot.png"},{"name":"文心一言","link":"https://yiyan.baidu.com/","description":"百度旗下 AI 聊天对话工具","image":"/images/tools/wenxinyiyan.png"},{"name":"通义千问","link":"https://tongyi.aliyun.com/qianwen/","description":"阿里巴巴旗下 AI 聊天对话工具","image":"/images/tools/tongyiqianwen.svg"},{"name":"讯飞星火","link":"https://xinghuo.xfyun.cn/","description":"科大讯飞星火认知 AI 大模型","image":"/images/tools/xinghuo.svg"},{"category":"绘画 AI","anchorId":"JUU3JUJCJTk4JUU3JTk0JUJCJTIwQUk7"},{"name":"Midjourney","link":"https://www.midjourney.com/","description":"AI 图像和插画生成工具","image":"/images/tools/midjourney.png"},{"name":"Adobe Firefly","link":"https://firefly.adobe.com/","description":"Adobe 推出的 AI 图像生成和编辑工具","image":"/images/tools/adobe-firefly.svg"},{"name":"Stable Diffusion","link":"https://stability.ai/","description":"最强开源 AI 绘画工具","image":"/images/tools/stability.png"},{"name":"Microsoft Designer","link":"https://designer.microsoft.com/home","description":"微软推出的在线设计海报和宣传图工具","image":"/images/tools/microsoft-designer.svg"},{"name":"文心一格","link":"https://yige.baidu.com/","description":"百度出品的 AI 绘画工具","image":"/images/tools/wenxinyiyan.png"},{"category":"技术社区","anchorId":"JUU2JThBJTgwJUU2JTlDJUFGJUU3JUE0JUJFJUU1JThDJUJB13"},{"name":"稀土掘金","link":"https://juejin.cn/","description":"一个帮助开发者成长的社区","image":"/images/tools/juejin.svg"},{"name":"V2EX","link":"https://www.v2ex.com/","description":"创意工作者们的社区","image":"/images/tools/v2ex.png"},{"name":"思否","link":"https://segmentfault.com/","description":"中国领先的开发者技术社区","image":"/images/tools/segmentfault.svg"},{"name":"博客园","link":"https://www.cnblogs.com/","description":"开发者的网上家园","image":"/images/tools/cnblogs.png"},{"name":"W2Solo","link":"https://w2solo.com/","description":"中文独立开发者社区","image":null},{"name":"电鸭社区","link":"https://eleduck.com/","description":"专注远程工作招聘交流","image":"/images/tools/dianyashequ.png"},{"name":"StackOverflow","link":"https://stackoverflow.com/","description":"全球最大的技术问答社区","image":"/images/tools/stackoverflow.png"},{"name":"开源中国","link":"https://www.oschina.net/","description":"目前国内最大的开源技术社区","image":"/images/tools/oschina.webp"},{"name":"InfoQ","link":"https://www.infoq.cn/","description":"一个实践驱动的技术社区资讯站点","image":"/images/tools/infoq.png"},{"name":"51CTO","link":"https://www.51cto.com/","description":"中国领先的 IT 技术网站","image":"/images/tools/51cto.webp"},{"name":"CSDN","link":"https://www.csdn.net/","description":"中文最大的技术社区","image":"/images/tools/csdn.png"},{"category":"部署托管","anchorId":"JUU5JTgzJUE4JUU3JUJEJUIyJUU2JTg5JTk4JUU3JUFFJUEx25"},{"name":"GitHub Pages","link":"https://pages.github.com/","description":"通过 GitHub 托管和发布的公共网页","image":"/images/tools/github.svg"},{"name":"Vercel","link":"https://vercel.com/","description":"Vercel's Frontend Cloud provides the developer experience and infrastructure to build, scale, and secure a faster, more personalized web.","image":"/images/tools/vercel.svg"},{"name":"Cloudflare Pages","link":"https://developers.cloudflare.com/pages/","description":"Create full-stack applications that are instantly deployed to the Cloudflare global network.","image":"/images/tools/cloudflare.svg"},{"name":"Netlify","link":"https://www.netlify.com/","description":"Netlify is the essential platform for the delivery of exceptional and dynamic web experiences, without limitations.","image":"/images/tools/netlify.svg"},{"name":"Railway","link":"https://railway.app/","description":"Railway is the cloud for building, shipping, and monitoring applications.","image":"/images/tools/railway.svg"},{"name":"Zeabur","link":"https://zeabur.com","description":"Say goodbye to deployment hassles. With Zeabur, bring your coding genius to life swiftly and smoothly.","image":"/images/tools/zeabur.png"}]},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="小举的阿勒泰" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/avatar.png">
                </a>
            
            <a class="site-name border-box" href="/">
               小举的阿勒泰
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-tags"></i>
                                
                                标签
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tools">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-tools"></i>
                                
                                工具
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-tags"></i>
                                </span>
                            
                            标签
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                </span>
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tools">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-tools"></i>
                                </span>
                            
                            工具
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            
                <div class="post-content-top border-box"
                     style="height: 260px"
                >
                    <div class="cover-post-title">
                        深入学习 JavaScript 系列（二)：This 关键字
                    </div>
                    <img class="post-cover" src="/images/posts/advanced-js/adjs-this.png"
                         onerror="this.style.display='none'"
                    >
                </div>
            

            <div class="post-content-bottom border-box has-cover">
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.png">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">小举</span>
                                
                                    <span class="author-badge">筑基</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-feather"></i>&nbsp;
                <span class="datetime">2024-04-26</span>
            </span>

            
                <span class="meta-info-item post-update-date">
                    <i class="icon fa-solid fa-arrows-rotate"></i>&nbsp;
                    <span class="datetime" data-updated="Tue Dec 03 2024 14:56:36 GMT+0000">2024-12-03</span>
                </span>
            
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/JavaScript/">JavaScript</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/JavaScript/">JavaScript</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/This/">This</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>8.5k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>33 分钟</span>
            </span>
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h2 id="1-关于-this"><a href="#1-关于-this" class="headerlink" title="1. 关于 this"></a>1. 关于 this</h2><p>This 关键字是 JavaScript 中最复杂的机制之一，它是一个很特别的关键字，被<strong>自动</strong>定义在所有<strong>函数</strong>的作用域中。但是即使是非常有经验的 JavaScript 开发者也很难说清楚它到底指向什么。在缺乏对 This 清晰认知的情况下，它对我们来说无异于一种魔法。</p>
<h3 id="1-1-为什么要用-this-呢？"><a href="#1-1-为什么要用-this-呢？" class="headerlink" title="1.1 为什么要用 this 呢？"></a>1.1 为什么要用 this 呢？</h3><p>在解释为什么要用 this 之前我们先来看一个代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&quot;Hello, I&#x27;m&quot;</span> + identify.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Eric&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.<span class="title function_">call</span>(me); <span class="comment">// &quot;ERIC&quot;</span></span><br><span class="line">identify.<span class="title function_">call</span>(you); <span class="comment">// &quot;JOHN&quot;</span></span><br><span class="line"></span><br><span class="line">speak.<span class="title function_">call</span>(me); <span class="comment">// &quot;Hello, I&#x27;m ERIC&quot;</span></span><br><span class="line">speak.<span class="title function_">call</span>(you); <span class="comment">// &quot;Hello, I&#x27;m JOHN&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码可以在<strong>不同的上下文对象</strong>（me 和 you）中<strong>重复</strong>使用函数<code>identify()</code>和<code>speak()</code>而不用针对每一个对象编写不同版本的函数。</p>
<p>如果不使用 this， 那就需要给<code>identify()</code>和<code>speak()</code>函数显示的传入一个上下文对象，像这样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identify</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> context.<span class="property">name</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&quot;Hello, I&#x27;m&quot;</span> + <span class="title function_">identify</span>(context);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identify</span>(you); <span class="comment">// &quot;JOHN&quot;</span></span><br><span class="line"><span class="title function_">speak</span>(me); <span class="comment">// &quot;Hello, I&#x27;m ERIC&quot;</span></span><br></pre></td></tr></table></figure>

<p>随着你的使用模式越来越复杂，显示的传递上下文对象会让代码变得越来越混乱。然而，this 提供了一种更优雅的方式来<strong>隐式的“传递”一个对象引用</strong>，因此可以将 API 设计的更加简洁并且易于复用，请记住：<strong>函数可以自动的引用合适的上下文对象是非常重要的。</strong></p>
<h3 id="1-2-对-this-的误解"><a href="#1-2-对-this-的误解" class="headerlink" title="1.2 对 this 的误解"></a>1.2 对 this 的误解</h3><p>在解释 this 是如何工作之前我们先来消除一些关于 this 的错误认知。</p>
<h4 id="1-2-1-误解一：this-指向自身"><a href="#1-2-1-误解一：this-指向自身" class="headerlink" title="1.2.1 误解一：this 指向自身"></a>1.2.1 误解一：this 指向自身</h4><p>顾名思义，我们很容易错误的把 this 理解为指向自身，为什么需要从函数内部引用函数自身呢？常见的场景时递归（从函数内部调用这个函数）。JavaScript 开发者通常会认为，既然把函数看作一个对象（JavaScript 中所有的函数都是对象），那么就可以在调用函数时存储<strong>状态</strong>，这当然是可行的，但是除了函数对象还有许多更适合存储状态的地方。不过我们先来分析一下这个模式，看看 this 是否如我们所想的那样指向函数本身。思考一下下面这个代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> + num);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 6</span></span><br><span class="line"><span class="comment">// foo 7</span></span><br><span class="line"><span class="comment">// foo 8</span></span><br><span class="line"><span class="comment">// foo 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>根据输出我们知道 foo 被调用了 4 次，但是 <code>foo.count</code>仍然是 0，显然从字面理解 this 是错误的。执行 <code>foo.count = 0</code> 时，的确向函数对象 foo 添加了一个属性，但是函数内部代码<code>this.count</code>中的 this 并不是指向 foo 这个函数对象，虽然熟悉名相同，但是对象却不同。</p>
<p>如果要从函数内部引用它自身，只使用 this 是不够的，一般你需要通过一个<strong>指向函数对象的词法标识符</strong>来引用它。思考一下下面这两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  foo.<span class="property">count</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这是一个匿名函数，函数无法指向自身</span></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>注意第二个函数中我们传给 setTimeout 的回调函数没有函数名称标识符（匿名函数），因此函数无法从内部引用自身。</p>
<blockquote>
<p>💡 有一种传统的但是现在已经被弃用和批判的方法是使用 arguments.callee 来引用当前正在运行的函数对象，这是唯一一种可以从匿名函数内部引用自身的方法了，但是更好的方法是避免使用匿名函数，至少在需要自身引用时使用具名函数。arguments.callee 已经被废弃了，不应该再使用它。</p>
</blockquote>
<p>所以对于我们的例子来说，另一种解决方法是使用 foo 标识符来代替 this 来引用函数自身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> + num);</span><br><span class="line">  <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">  foo.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 6</span></span><br><span class="line"><span class="comment">// foo 7</span></span><br><span class="line"><span class="comment">// foo 8</span></span><br><span class="line"><span class="comment">// foo 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>然而这种方式回避了 this 的问题，完全依赖于变量 foo 的词法作用域。</p>
<p>另外一种方法是强制 this 指向 foo 函数对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> + num);</span><br><span class="line">  <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    foo.<span class="title function_">call</span>(foo, i); <span class="comment">// 这里强制 this 指向 foo 函数对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 6</span></span><br><span class="line"><span class="comment">// foo 7</span></span><br><span class="line"><span class="comment">// foo 8</span></span><br><span class="line"><span class="comment">// foo 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-误解二：this-的作用域"><a href="#1-2-2-误解二：this-的作用域" class="headerlink" title="1.2.2 误解二：this 的作用域"></a>1.2.2 误解二：this 的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域，这种说法在某种情况下是正确的，但是在其他情况下却是错误的。</p>
<p>需要明确的是，<strong>this 在任何情况下都不指向函数的词法作用域</strong>。在 JavaScript 内部，作用域确实和对象很类似，可见的标识符都是它的属性，但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。</p>
<p>思考一下下面的这个例子，它试图跨越边界，使用 this 来隐式引用函数的词法作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>这个例子出自一个公共社区互助论坛中的精华代码，它清楚的展示了 this 多么容易误导人。首先，这段代码试图通过 <code>this.bar()</code>来引用 bar 函数，例子中能调用成功纯属意外，调用 bar 最自然的方式是省略前面的 this，直接使用词法作用域的查找机制来引用 bar 函数。此外，这段代码还试图使用 this 联通 foo 和 bar 的词法作用域，从而让 bar 函数内部能访问到 foo 函数内部的局部变量 a。这当然是不可能实现的，使用 this 不可能在词法作用域中查找到什么的。</p>
<h3 id="1-3-this-到底是什么？"><a href="#1-3-this-到底是什么？" class="headerlink" title="1.3 this 到底是什么？"></a>1.3 this 到底是什么？</h3><p>排除了一些误解后，我们来看看 this 到底是一种什么样的机制？</p>
<p>this 是在<strong>运行时</strong>绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong></p>
<p>当一个函数被调用时，会创建一个<strong>活动记录</strong>（有时候也被称为<strong>执行上下文</strong>）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个活动记录中的一个属性，会在函数执行的过程中用到。</p>
<h2 id="2-this-全面解析"><a href="#2-this-全面解析" class="headerlink" title="2. this 全面解析"></a>2. this 全面解析</h2><p>我们刚刚排出了一些对 this 的误解，并且明白了每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。接下来我们来探究一下如何寻找到函数的调用位置，从而判断函数在执行过程中会如何绑定 this。</p>
<h3 id="2-1-调用位置"><a href="#2-1-调用位置" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h3><p>所谓调用位置就是函数在代码中被<strong>调用</strong>的位置而不是被<strong>声明</strong>的位置，想要准确的找到函数被调用的位置，最重要的是分析<strong>调用站</strong>（就是为了到达当前执行位置所调用的所有函数），我们关心的调用位置就是在当前正在执行的函数中的<strong>前一个调用</strong>中。举个例子来说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是 全局作用域 -&gt; baz，因此当前的调用位置是调用 baz 的地方，也就是全局作用域</span></span><br><span class="line">  <span class="title function_">consoleloc</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//当前的调用栈是 全局作用域 -&gt; baz -&gt; bar，因此当前的调用位置是调用 bar 的地方，也就是 baz 函数内部</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前的调用栈是 全局作用域 -&gt; baz -&gt; bar -&gt; foo，因此当前的调用位置是调用 foo 的地方，也就是 bar 函数内部</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// baz 的调用位置， 这里是全局作用域</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-绑定规则"><a href="#2-2-绑定规则" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h3><p>调用位置确定后，我们就可以确定 this 的绑定规则了，判断需要应用下面<strong>四条</strong>规则中的哪一条：</p>
<h4 id="2-2-1-默认绑定"><a href="#2-2-1-默认绑定" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 默认绑定</h4><p>第一条就是最常用的函数调用类型：<strong>独立函数调用</strong>。可以把这条规则看作是无法应用其他规则时的默认规则。</p>
<p>思考下面这个代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>应该注意到的第一件事是：<strong>声明在全局作用域中的变量（比如 <code>var a = 2</code>）就是全局对象的一个同名属性。</strong> 它们本质上就是一个东西，并不是通过复制得到的。我们看到当调用<code>foo()</code>时，<code>this.a</code>被解析成了全局变量 a，这是因为在这个例子中应用了 this 的默认绑定，this 指向全局对象。</p>
<p>如何确定这里时应用了默认绑定呢？很简单，我们分析一下调用位置来看看 foo 是如何被调用的。在这个例子中，foo 是直接使用<strong>不带任何修饰的函数引用</strong>进行调用的，所以只能应用默认绑定，无法应用其他规则。</p>
<p>如果使用严格模式（strict mode），则不能将全局对象用作默认绑定，此时 this 会被绑定到 undefined。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-隐式绑定"><a href="#2-2-2-隐式绑定" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 隐式绑定</h4><p>第二条需要考虑的规则是<strong>调用位置是否有上下文对象</strong>，或者说是否被某个对象拥有或者包含，思考一下下面这个代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>注意 foo 函数的<strong>声明方式</strong>，以及之后是如何被当作引用属性添加到 obj 中的。无论是直接在 obj 中定义还是先定义再添加为 obj 的属性，<strong>这个函数严格来说都不属于 obj 对象</strong>。</p>
<p>然而调用位置会使用 obj 上下文来引用函数，因此你可以认为<strong>函数被调用时 obj 对象“拥有”或者“包含”函数引用</strong>。</p>
<p>无论你如何称呼这个模式，当 foo 被调用时，它的前面确实加上了对 obj 的引用。<strong>当函数引用有上下文对象时，隐式绑定规则会把函数调用时的 this 绑定到这个上下文对象</strong>。此时<code>this.a</code>和<code>obj.a</code>是一样的。</p>
<p>另外需要注意对象属性引用链中只有上一层或者最后一层在调用位置中起作用，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">obj2</span>: obj2,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj1.<span class="property">obj2</span>.<span class="title function_">foo</span>(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>一个最常见的 this 绑定问题就是被<strong>隐式绑定</strong>的函数会丢失绑定对象，也就是说它会应用<strong>默认绑定</strong>，从而把 this 绑定到全局对象或者 undefined 上（取决于是否是严格模式）。思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>; <span class="comment">// 函数别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是<strong>foo 函数本身</strong>，因此此时的<code>bar()</code>其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>另外一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的 fn 引用是 foo 函数本身</span></span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>参数传递就是一种<strong>隐式赋值</strong>，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。那如果我们把函数传入语言内置的函数（比如 setTimeout）而不是自己定义的函数呢？结果是一样的，没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>, <span class="number">1000</span>); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中的 setTimeout 函数的实现和下面这段伪代码类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeout</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">// 等待 delay 毫秒</span></span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>回调函数丢失 this 绑定是非常常见的</strong>。除此之外，<strong>调用回调函数的函数可能会修改 this</strong>。无论哪种情况，this 的改变都是意想不到的，实际上你根本就无法控制回调函数的执行方式，因此也就无法控制调用位置得到期望的绑定。</p>
<h4 id="2-2-3-显式绑定"><a href="#2-2-3-显式绑定" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 显式绑定</h4><p>在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</p>
<p>如果我们不想在对象内部包含一个函数的引用，但是又想<strong>在某个对象上强制调用某个函数</strong>该怎么办呢？</p>
<p>答案就是使用函数的 call 和 apply 方法，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call 和 apply 方法。</p>
<p>这两个方法的第一个参数是一个<strong>对象</strong>，这个对象是给 this 准备的，接着在调用的时候将其绑定到 this，因为我们可以直接指定 this 的绑定对象，因此称之为<strong>显示绑定</strong>。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">// 2, 通过foo.call(obj),我们强制把它的this绑定到了obj上</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 使用 call 和 apply 方法时，如果第一个参数你传入了一个原始值（字符串、布尔或者数字类型），来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String()、 new Boolean()或者 new Number()），这被称为“装箱”（boxing）。</p>
</blockquote>
<p>遗憾的是，显示绑定并不能解决我们之前遇到的丢失绑定的问题。但是显示绑定的一个变种（<strong>硬绑定</strong>）可以解决这个问题，思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  foo.<span class="title function_">call</span>(obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(bar, <span class="number">1000</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬绑定的bar函数不可能再修改它的this</span></span><br><span class="line">bar.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>我们创建了函数 bar， 并在它的内部手动调用了&#96;foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj 上。无论之后如何调用 bar，它总会手动在 obj 上调用 foo。这种绑定是一种<strong>强制绑定</strong>，称之为<strong>硬绑定</strong>。</p>
<p>硬绑定的一个典型的应用场景就是创建一个<strong>包裹函数</strong>，负责接收参数并返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// arguments 是调用bar时实际接受到的参数，是一个类数组对象</span></span><br><span class="line">  <span class="keyword">return</span> foo.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是创建一个可重复使用的辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">fn, thisContext</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(thisContext, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">bind</span>(foo, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>硬绑定是一种非常有用的模式，ES5 提供了内置的方法 <code>Function.prototype.bind</code>，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj); <span class="comment">// 返回一个新的函数，这个函数被硬绑定到了obj上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>bind 会返回一个<strong>硬编码</strong>的新函数，它会把指定的参数设置为 this 的上下文并调用原始函数。</p>
<p>JavaScript 语言和宿主环境的许多新的内置函数，以及第三方库的许多函数，都提供了一个可选的参数，通常被称为“上下文”（context），这个参数可以用来显式指定函数的 this 绑定对象。它和 bind 的作用一样，确保你的函数使用指定的 this。 举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(el, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;awesome&#x27;</span>,</span><br><span class="line">&#125;[</span><br><span class="line">  <span class="comment">// 调用 foo 函数，并显式指定 this 的绑定对象为 obj</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">].<span class="title function_">forEach</span>(foo, obj); <span class="comment">// 1 awesome, 2 awesome, 3 awesome</span></span><br></pre></td></tr></table></figure>

<p>这些函数实际上就是通过 call 或 apply 实现了显示绑定。</p>
<h4 id="2-2-4-new-绑定"><a href="#2-2-4-new-绑定" class="headerlink" title="2.2.4 new 绑定"></a>2.2.4 new 绑定</h4><p>这是最后一条 this 的绑定规则，不过在详细介绍之前我们需要先澄清一个非常常见的关于 JavaScript 中函数和对象的误解。</p>
<p>在传统的面相类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会自动调用类中的构造函数，通常的的使用形式是这样的：<code>something = new myClass(args)</code>; JavaScript 也有一个 new 操作符，使用起来也和那些语言差不多，因此绝大多数开发着都认为 JavaScript 也和那些语言的 new 的机制是一样的。然而，<strong>JavaScript 中 new 的机制和面向类的语言完全不同</strong>。</p>
<p>在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。<strong>它们并不会属于某个类，也不会实例化一个类</strong>。实际上，它们甚至都不能说是一种特殊的函数类型，它们和普通的函数没有任何区别，只是被 new 操作符调用的<strong>普通函数</strong>而已。</p>
<p>ES5 这样描述 Number() 作为构造函数时的行为：</p>
<blockquote>
<p>Number 构造函数：当 Number 在 new 表达式中被调用时，它是一个构造函数，它会初始化新建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数（比如 Number()）在内的所有函数都可以用 new 来调用，这种函数调用被称为<strong>构造函数调用</strong>。这里有一个重要但是非常细微的区别：<strong>实际上并不存在所谓的“构造函数”，只有对函数的“构造调用”</strong>。</p>
<p>使用 new 来调用函数，或者发生函数的构造调用时，会自动执行下面的操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个对象会被执行[[Prototype]]链接，因此会继承构造函数的原型。</li>
<li>这个对象会绑定到函数调用的 this 关键字。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title function_">foo</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>使用 new 来调用 foo 时，我们会构造一个新的对象并把它绑定到 foo 调用中的 this 上。<strong>new 是最后一种可以影响函数调用时 this 绑定行为的方法， 我们称之为 new 绑定</strong>。</p>
<h3 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h3><p>在函数调用中决定 this 绑定的四条规则中，如果某个位置可以应用多条规则该怎么办？换句话说，这四条规则的优先级是什么？</p>
<p>毫无疑问，<strong>默认绑定的优先级是四条规则中最低的</strong>，所以可以先不考虑它。隐式绑定和显示绑定哪个优先级更高呢？我们不妨来测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>(obj1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>显示绑定的优先级更高</strong>，因此在判断时应该先考虑是否存在显示绑定。</p>
<p>接下来需要弄清楚 new 绑定和隐式绑定的优先级高低：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(<span class="number">2</span>); <span class="comment">// 隐式绑定，this 绑定到 obj1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2, <span class="number">3</span>); <span class="comment">// 显示绑定，this 绑定到 obj2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>(<span class="number">4</span>); <span class="comment">// new 绑定，this 绑定到新创建的对象而不是 obj1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>new 绑定比隐式绑定优先级高</strong>。最后，new 绑定和显示绑定哪个优先级更高呢？</p>
<p>还记得硬绑定是如何工作的吗？<code>Function.prototype.bind()</code>会创建一个新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。这样看起来硬绑定（也是显示绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。我们来测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj1); <span class="comment">// 新返回的 bar 函数将 this 硬绑定到了 obj1</span></span><br><span class="line"><span class="title function_">bar</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 将硬绑定了 obj1 的新的函数 bar 作为构造函数调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">a</span>); <span class="comment">// 3 可以看到 this 指向了新新创建的对象 baz 上而不是 obj1</span></span><br></pre></td></tr></table></figure>

<p>出乎意料，尽管 bar 函数被硬绑定到了 obj1 上，但是 <code>new bar(3)</code> 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj）调用 bar 中的 this，因为使用了 new 绑定，我们得到了一个名为 baz 的新的对象，并且 baz.a 的值为 3。</p>
<p>来看一下 ES5 中内置的 Function.prototype.bind() 方法的一种实现（来自 MDN）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果调用 bind 方法的对象不是函数，则抛出一个 TypeError 异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">        <span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 获取调用 bind 方法时传入的参数, 注意这里是从 index 1 开始，因为第一个参数是要绑定到 this 的对象</span></span><br><span class="line">    <span class="keyword">var</span> fToBind = <span class="variable language_">this</span>; <span class="comment">// 将调用 bind 方法的函数保存下来</span></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 空函数, 作为返回的函数的原型</span></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 包裹函数</span></span><br><span class="line">      <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(</span><br><span class="line">        <span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="variable language_">this</span> : oThis,</span><br><span class="line">        aArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 为 fNOP 设置原型</span></span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>(); <span class="comment">// 为 fBound 设置原型，并将其原型设置为 fNOP 的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound; <span class="comment">// 返回包裹函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现的核心部分是这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="variable language_">this</span> : oThis;</span><br><span class="line"><span class="comment">// 以及这部分：</span></span><br><span class="line">fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br><span class="line">fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br></pre></td></tr></table></figure>

<p>这部分代码是模拟 bind 方法实现中最关键的一部分，处理了<strong>绑定函数的调用方式</strong>和<strong>构造函数行为</strong>的兼容性问题。我们来逐步分析：</p>
<p>首先是这句代码：<code>this instanceof fNOP &amp;&amp; oThis ? this : oThis</code>:</p>
<ul>
<li>bind 的目标是创建一个新的函数（fBound），并绑定一个指定的 this 值（oThis）以及一组参数（aArgs）。</li>
<li>新的函数（fBound）可以以两种方式调用：<ol>
<li>普通函数调用：绑定的 this 值应该是 oThis。</li>
<li>构造函数调用：如果用 new 调用 fBound，this 应该指向新创建的对象，而不是绑定时的 oThis。</li>
</ol>
</li>
<li><code>this instanceof fNOP</code>正是用来判断当前的调用方式是否是通过 new 调用的（即构造函数调用），fBound 的原型被设置为 fNOP 的实例（<code>fBound.prototype = new fNOP()</code>）。因此，如果当前的 this 是 fNOP 的实例，则说明 fBound 是通过 new 调用的。</li>
<li>如果 <code>this instanceof fNOP</code>为真，进一步检查是否存在 oThis。<code>&amp;&amp; oThis</code>是为了确保在普通函数调用时能正确绑定到指定的对象。</li>
</ul>
<p>完整的逻辑就是：如果 this 是 fNOP 的实例（即通过 new 调用），返回当前的 this，表示 fBound 被用作构造函数，this 应该是新创建的对象。如果不是构造函数调用，返回 oThis，表示普通的函数调用中，this 应该绑定到指定的对象 oThis。</p>
<p>最后<code>fNOP.prototype = this.prototype;</code>的作用是确保通过 bind 创建的函数（fBound）能够继承原始函数（fToBind）的原型链，从而保持一致的原型行为。</p>
<p>简单的说： <strong>如果硬绑定函数是通过 new 调用的，则会忽略硬绑定的 this，而是将 this 绑定到新创建的对象上</strong>。</p>
<p>那为啥非得在 new 中使用硬绑定的函数呢？直接使用普通函数不行吗？其实主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化的时候就可以只传其余参数。bind 函数的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其余参数都传递给下层的函数（这种技术被称为“部分应用”，是“柯里化”的一种）。举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之所以使用 null 是因为在本例子中我们不关心硬绑定的 this 是什么，反正使用 new 时都会忽略它</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">val</span>); <span class="comment">// &#x27;p1p2&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-判断-this"><a href="#2-4-判断-this" class="headerlink" title="2.4 判断 this"></a>2.4 判断 this</h3><p>现在我们基本上可以根据优先级来判断函数在某个调用位置应用的是哪条规则了，可以按照下面的顺序来进行判断：</p>
<ol>
<li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 <code>var bar = new foo();</code></li>
<li>函数是否通过 call、apply（显示绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。 <code>var bar = foo.call(obj2);</code></li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 <code>obj1.foo();</code></li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。<code>var bar = foo();</code></li>
</ol>
<p>这几条基本上涵盖了所有函数正常调用时 this 的绑定原理了。然而，凡事总有例外。</p>
<h3 id="2-5-绑定例外"><a href="#2-5-绑定例外" class="headerlink" title="2.5 绑定例外"></a>2.5 绑定例外</h3><p>在某些情况下 this 的绑定行为会出乎意料之外，你认为应当应用其他规则时，实际上应用的可能是默认绑定规则。</p>
<h4 id="2-5-1-被忽略的-this"><a href="#2-5-1-被忽略的-this" class="headerlink" title="2.5.1 被忽略的 this"></a>2.5.1 被忽略的 this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>什么情况下会传入 null 呢？一种非常常见的做法是使用 apply 来“展开”一个数组，并当作参数传入一个函数。类似的使用 bind 也可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a:&#x27;</span> + a + <span class="string">&#x27;, b:&#x27;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把数组“展开“成参数</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>

<p>在这两个例子中，函数都不关心 this，但是你仍旧需要传入一个占位值，这时 null 可能是一个不错的选择。不过总是使用 null 来忽略 this 绑定可能产生一些副作用。<strong>如果某个函数确实使用了 this（比如第三方库的某个函数）），那默认绑定规则会把 this 绑定到全局对象，这可能会导致不可预计的后果。</strong></p>
<blockquote>
<p>💡 关于展开一个数组，ES6 提供了 … 操作符可以代替 apply 来“展开”数组，foo(…[1,2]) 和 foo.apply(null, [1,2]) 效果相同，这样可以避免不必要的 this 绑定。</p>
</blockquote>
<p>一种“更安全”的做法是传入一个“特殊的对象“，把 this 绑定到这个对象上不会对你的程序产生任何副作用，这个对象就是<strong>空的非委托对象</strong>。在 JavaScript 中，创建一个空对象最简单的方法就是使用<code>Object.create(null)</code>，它和 <code>&#123;&#125;</code>很像，但是并不会创建<code>Object.prototype</code>这个委托，所以它比<code>&#123;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a:&#x27;</span> + a + <span class="string">&#x27;, b:&#x27;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空的非委托对象</span></span><br><span class="line"><span class="keyword">var</span> Ø = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组展开成参数</span></span><br><span class="line">foo.<span class="title function_">apply</span>(Ø, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(Ø, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>使用 Ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，Ø 表示“我希望 this 是空”，这比 null 的含义更清楚。</p>
<h4 id="2-5-2-间接调用"><a href="#2-5-2-间接调用" class="headerlink" title="2.5.2 间接调用"></a>2.5.2 间接调用</h4><p>另一个需要注意的是我们可能（有意或者无意）创建一个函数的“间接引用”，在这种情况下，调用这个函数会使用默认绑定规则。<strong>间接引用</strong>最容易在赋值时发生：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line">o.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line">(p.<span class="property">foo</span> = o.<span class="property">foo</span>)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>赋值表达式<code>(p.foo = o.foo)</code>的返回值是目标函数的引用</strong>，因此调用位置是<code>foo()</code>而不是<code>p.foo()</code>或者<code>o.foo()</code>。在这种情况下，应用的是默认绑定规则。</p>
<h4 id="2-5-3-软绑定"><a href="#2-5-3-软绑定" class="headerlink" title="2.5.3 软绑定"></a>2.5.3 软绑定</h4><p>之前我们提到了硬绑定，这种绑定方式可以把 this 绑定到指定的对象（除了使用 new 进行调用时），当时有时候硬绑定会大大降低函数的灵活性，<strong>使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this 了。</strong>如果可以给默认绑定指定一个除了全局对象和 undefine 以外的值，就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改 this 的能力。比如一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> curried = [].<span class="property">silce</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 保存剩余参数</span></span><br><span class="line">    <span class="keyword">var</span> bound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">        !<span class="variable language_">this</span> || <span class="variable language_">this</span> === (<span class="variable language_">window</span> || <span class="variable language_">global</span>) ? obj : <span class="variable language_">this</span>,</span><br><span class="line">        curried.<span class="property">concat</span>.<span class="title function_">apply</span>(curried, <span class="variable language_">arguments</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">    bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是这句代码：<code>!this || this === (window || global) ? obj : this</code>,它将决定 <code>fn.apply</code> 方法的 this 值：如果 this 绑定到了全局对象或者 undefined， 那就把 this 绑定到指定的对象 obj 上，否则就保持原来的 this。接下来看看如何使用这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name:&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.<span class="title function_">softBind</span>(obj1); <span class="comment">// fooOBJ 就是上边代码片段中返回的 bound 函数</span></span><br><span class="line"><span class="title function_">fooOBJ</span>(); <span class="comment">// name:obj1，这里的效果和硬绑定一样</span></span><br><span class="line"></span><br><span class="line">obj2.<span class="property">foo</span> = foo.<span class="title function_">softBind</span>(obj1);</span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// name:obj2, 注意这里不一样了，这里是在obj2的上下文中调用foo的（属于隐式绑定），如果是硬绑定的话隐式绑定是无法修改 this 的，this还会是obj1， 然而这里是软绑定，this会被绑定到obj2</span></span><br><span class="line"></span><br><span class="line">fooOBJ.<span class="title function_">call</span>(obj3); <span class="comment">// name:obj3, 这里我们用显示绑定的方式调用 fooOBJ，this 被绑定到了 obj3 上，还是和硬绑定不一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.<span class="property">foo</span>, <span class="number">100</span>); <span class="comment">// name:obj1, 这里obj2.foo是引擎直接在全局调用的，按照默认绑定规则，this 应该绑定到了全局对象，然而软绑定仍旧会把 this 绑定到 obj1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-this-的词法"><a href="#2-6-this-的词法" class="headerlink" title="2.6 this 的词法"></a>2.6 this 的词法</h3><p>前面的四条规则已经可以涵盖所有正常的函数，但是 ES6 引入了一种无法使用这些规则的特殊类型的函数：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符<code>=&gt;</code>定义的。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局作用域）来决定 this。</strong></p>
<p>来看一下箭头函数的词法作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this 继承自 foo</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">call</span>(obj1);</span><br><span class="line">bar.<span class="title function_">call</span>(obj2); <span class="comment">// 2 注意这里的 this 并不是 obj2，而是 obj1</span></span><br></pre></td></tr></table></figure>

<p>foo 内部创建的箭头函数会“捕获”调用时 foo 的 this。由于 foo 的 this 绑定到 obj1，因此 bar（引用的是箭头函数）的 this 也会绑定到 obj1，<strong>箭头函数的绑定无法被修改（new 也不行）。</strong></p>
<p>箭头函数最常用于回调函数中，如事件处理器或者定时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 this 在词法上继承自 foo</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>箭头函数可以像 bind 一样确保函数的 this 被绑定到指定的对象，此外其重要性还体现在<strong>它用更常见的词法作用域取代了传统 this 机制。</strong>实际上在 ES6 之前我们就已经在使用一种几乎和箭头函数一模一样的模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">a</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>self = this</code>和箭头函数看起来都可以取代 bind，但是从本质上来说，它们想替换的是 this 机制。</p>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/JavaScript/">JavaScript</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/This/">This</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/04/12/advance-javascript/series-02-closure/"
                                   title="深入学习 JavaScript 系列（二)：闭包"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">深入学习 JavaScript 系列（二)：闭包</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%85%B3%E4%BA%8E-this"><span class="nav-text">1. 关于 this</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-this-%E5%91%A2%EF%BC%9F"><span class="nav-text">1.1 为什么要用 this 呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AF%B9-this-%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="nav-text">1.2 对 this 的误解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E8%AF%AF%E8%A7%A3%E4%B8%80%EF%BC%9Athis-%E6%8C%87%E5%90%91%E8%87%AA%E8%BA%AB"><span class="nav-text">1.2.1 误解一：this 指向自身</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E8%AF%AF%E8%A7%A3%E4%BA%8C%EF%BC%9Athis-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.2.2 误解二：this 的作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-this-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.3 this 到底是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-this-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="nav-text">2. this 全面解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE"><span class="nav-text">2.1 调用位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="nav-text">2.2 绑定规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.1 默认绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.2 隐式绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.3 显式绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-new-%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.4 new 绑定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">2.3 优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%A4%E6%96%AD-this"><span class="nav-text">2.4 判断 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96"><span class="nav-text">2.5 绑定例外</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84-this"><span class="nav-text">2.5.1 被忽略的 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="nav-text">2.5.2 间接调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E8%BD%AF%E7%BB%91%E5%AE%9A"><span class="nav-text">2.5.3 软绑定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-this-%E7%9A%84%E8%AF%8D%E6%B3%95"><span class="nav-text">2.6 this 的词法</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
    &copy;&nbsp;<span>2021</span>&nbsp;-&nbsp;2024
    
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">小举</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%85%B3%E4%BA%8E-this"><span class="nav-text">1. 关于 this</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-this-%E5%91%A2%EF%BC%9F"><span class="nav-text">1.1 为什么要用 this 呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AF%B9-this-%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="nav-text">1.2 对 this 的误解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E8%AF%AF%E8%A7%A3%E4%B8%80%EF%BC%9Athis-%E6%8C%87%E5%90%91%E8%87%AA%E8%BA%AB"><span class="nav-text">1.2.1 误解一：this 指向自身</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E8%AF%AF%E8%A7%A3%E4%BA%8C%EF%BC%9Athis-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.2.2 误解二：this 的作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-this-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.3 this 到底是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-this-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="nav-text">2. this 全面解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE"><span class="nav-text">2.1 调用位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="nav-text">2.2 绑定规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.1 默认绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.2 隐式绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.3 显式绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-new-%E7%BB%91%E5%AE%9A"><span class="nav-text">2.2.4 new 绑定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">2.3 优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%A4%E6%96%AD-this"><span class="nav-text">2.4 判断 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96"><span class="nav-text">2.5 绑定例外</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84-this"><span class="nav-text">2.5.1 被忽略的 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="nav-text">2.5.2 间接调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E8%BD%AF%E7%BB%91%E5%AE%9A"><span class="nav-text">2.5.3 软绑定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-this-%E7%9A%84%E8%AF%8D%E6%B3%95"><span class="nav-text">2.6 this 的词法</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/anime.min.js"></script>

<!-- local search -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/local-search.min.js"></script>


<!-- lazyload -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/lazyload.min.js"></script>


<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/post-helper.min.js"></script>

        <!-- toc -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/toc.min.js"></script>
        

        <!-- copyright-info -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/copyright-info.min.js"></script>
        

        <!-- share -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/share.min.js"></script>
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
    

</body>
</html>
