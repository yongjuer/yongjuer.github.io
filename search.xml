<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常用的 git 命令清单</title>
    <url>/2022/03/20/basic-git-usage/</url>
    <content><![CDATA[<h1 id="常用的-Git-命令清单"><a href="#常用的-Git-命令清单" class="headerlink" title="常用的 Git 命令清单"></a>常用的 Git 命令清单</h1><p>本文收录在日常开发中经常使用到的 Git 命令，持续更新…</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/git.png"
                        alt="git desc" title="git desc"
                 ></p>
<ul>
<li>Workplace: 工作区</li>
<li>Index &#x2F; Stage: 暂存区</li>
<li>Repository: 仓库区</li>
<li>Remote: 远程仓库</li>
</ul>
<h2 id="新建代码仓库"><a href="#新建代码仓库" class="headerlink" title="新建代码仓库"></a>新建代码仓库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个 Git 代码仓库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为 Git 代码仓库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的 Git 配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 Git 配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前的用户信息</span></span><br><span class="line">$ git config --list --global | grep user</span><br></pre></td></tr></table></figure>

<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加&#x2F;删除文件"></a>增加&#x2F;删除文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：删除前端项目中的 node_modules</span></span><br><span class="line">$ git <span class="built_in">rm</span> -r --cached node_modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次 commit 之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有 diff 信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的 commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次 commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定 commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个 commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有 tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个 tag 在当前 commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个 tag 在指定 commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地 tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程 tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 tag 信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定 tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有 tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个 tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 commit 历史，以及每次 commit 发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 commit 之后的所有变动，每个 commit 占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次 diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去 5 次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个 commit 的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新 commit 之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个 commit 的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次 commit 保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个 commit，用来撤销指定 commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前 Git 版本</span></span><br><span class="line">$ git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>细说 Flex 布局</title>
    <url>/2023/03/20/flex/</url>
    <content><![CDATA[<h2 id="1-什么是-Flexbox？"><a href="#1-什么是-Flexbox？" class="headerlink" title="1. 什么是 Flexbox？"></a>1. 什么是 Flexbox？</h2><p>Flexbox 是“Flexible Box Layout”的缩写。它是一个 CSS 布局模型，可以简化复杂布局的创建。它提供了一种灵活的方式来对齐元素并在容器元素内分配空间。</p>
<p>在 Flexbox 出现之前，创建复杂的布局和响应式网页非常艰难。你需要 CSS 浮动和位置属性的组合。这需要许多变通方法和技巧。但使用 Flexbox，你现在可以面对更少的困难，使用更少的代码行数来实现以下操作：</p>
<ul>
<li>使用 <code>justify-content</code> 和 <code>align-items</code> 等属性对齐和居中元素。</li>
<li>无需编写大量媒体查询即可开发响应式布局。</li>
<li>在不改变 HTML 结构的情况下重新排序元素。</li>
<li>创建相同高度的列，无需任何额外的 HTML 元素或背景图片。</li>
</ul>
<h2 id="2-如何使用-Flexbox？"><a href="#2-如何使用-Flexbox？" class="headerlink" title="2. 如何使用 Flexbox？"></a>2. 如何使用 Flexbox？</h2><p>Flexbox 布局模型是双向的。这意味着你可以按行、列或两者排列元素。</p>
<h3 id="2-1-主轴和交叉轴"><a href="#2-1-主轴和交叉轴" class="headerlink" title="2.1 主轴和交叉轴"></a>2.1 主轴和交叉轴</h3><p>关于 Flexbox，你首先需要了解的是轴的概念。每个 Flex 容器（ <code>display</code> 属性设置为 flex 或 <code>inline-flex</code> 的元素）都有一个主轴和一个交叉轴。主轴是水平的还是垂直的，具体取决于 <code>flex-direction</code> 的值。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/flex-axis.png"
                        alt="Flex 轴示例"
                 ></p>
<p>在这个示例中，主轴是水平的，交叉轴是垂直的。<code>flex-direction</code> 的值是 <code>row</code>。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/flex-axis-02.png"
                        alt="Flex 轴示例"
                 ></p>
<p>在这个示例中，主轴是垂直的，交叉轴是水平的。<code>flex-direction</code> 的值是 <code>column</code>。</p>
<h3 id="2-2-Flex-容器和-Flex-子项"><a href="#2-2-Flex-容器和-Flex-子项" class="headerlink" title="2.2 Flex 容器和 Flex 子项"></a>2.2 Flex 容器和 Flex 子项</h3><p>要使用 Flexbox 的所有属性，你需要将元素的 <code>display</code> 属性设置为 <code>flex</code> 或 <code>inline-flex</code>。这将使元素成为 Flex 容器，并且该元素的子元素变成 Flex 子项。 举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This paragraph is not a flex item<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.container</code> 元素现在是一个 Flex 容器。这三个 <code>div</code> 元素是 <code>.container</code> 元素的<strong>直接</strong>子元素，这使得它们成为 Flex 子项。<strong>但第三个 <code>div</code> 内的段落元素不是 Flex 子项。这是因为它不是 <code>.container</code> 元素的直接子元素。</strong></p>
<h3 id="2-3-Flex-和-Inline-flex"><a href="#2-3-Flex-和-Inline-flex" class="headerlink" title="2.3 Flex 和 Inline-flex"></a>2.3 Flex 和 Inline-flex</h3><p>使用 <code>flex</code> 和 <code>inline-flex</code> 都可以使元素成为 Flex 容器。不同之处在于它们<strong>与周围元素的交互方式</strong>。</p>
<ul>
<li><code>display: flex</code>：这使得 Flex 容器的行为类似块级元素。Flex 容器<strong>占据其父元素的整个可用宽度</strong>。它会在新的一行开始，并且其后的元素也会在新的一行开始。比如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Button One<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* Flex Container */</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gold&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Button Two<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-01.png"
                        alt="Flex 容器示例"
                 ></p>
<p>如上所示，当你使用 <code>display: flex</code> 时，Flex 容器的行为类似于块元素，<code>.container</code> 元素占据了主体（其父元素）的整个可用宽度。</p>
<ul>
<li><code>display: inline-flex</code>：这使得 Flex 容器的行为类似于内联元素。Flex 容器<strong>只占据它的内容宽度</strong>。它不会在新的一行开始，而是与周围元素在同一行。如果将上面的例子改为 <code>display: inline-flex</code>,则效果如下所示：</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-03.png"
                        alt="Inline-flex 容器示例"
                 ></p>
<p>如图所示，Flex 容器不占据其父容器的整个宽度。它仅使用其内容所需的水平空间。</p>
<h2 id="3-Flex-容器属性"><a href="#3-Flex-容器属性" class="headerlink" title="3. Flex 容器属性"></a>3. Flex 容器属性</h2><p>Flex 容器属性允许你控制 Flex 容器内 Flex 子项的布局和对齐方式。</p>
<blockquote>
<p>⚠️ 注意：以下属性仅适用于 Flex 容器，而不是 Flex 子项。</p>
</blockquote>
<h3 id="3-1-flex-direction-属性"><a href="#3-1-flex-direction-属性" class="headerlink" title="3.1 flex-direction 属性"></a>3.1 flex-direction 属性</h3><p><code>flex-direction</code> 属性决定主轴的方向。定义了 Flex 子项的显示方向,它可以取以下值中的任意一个：</p>
<ul>
<li><code>row</code>：默认值。主轴从左到右。</li>
<li><code>row-reverse</code>：主轴从右到左。</li>
<li><code>column</code>：主轴从上到下。</li>
<li><code>column-reverse</code>：主轴从下到上。</li>
</ul>
<p>让我们看一个例子，看看它是如何工作的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;names-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jill&quot;</span>&gt;</span>1. JILL<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span>&gt;</span>2. JOHN<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jane&quot;</span>&gt;</span>3. JANE<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>4. JACK<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flex-direction: row</code>: 这会从左到右水平显示 Flex 子项。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-04.png"
                        alt="Flex Direction 示例"
                 ></p>
<p><code>flex-direction: row-reverse</code>: 这会从右到左水平显示 Flex 子项。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-05.png"
                        alt="Flex Direction 示例"
                 ></p>
<p><code>flex-direction: column</code>: 这会从上到下垂直显示 Flex 子项。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-06.png"
                        alt="Flex Direction 示例"
                 ></p>
<p><code>flex-direction: column-reverse</code>: 这会从下到上垂直显示 Flex 子项。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-07.png"
                        alt="Flex Direction 示例"
                 ></p>
<blockquote>
<p>⚠️ 当你使用 <code>row-reverse</code> 和 <code>column-reverse</code> 时，有些事情你需要记住。正如你已经看到的，这两个值会影响屏幕上元素的视觉顺序。<strong>但是这些元素在 HTML 中的顺序保持不变</strong>，而这些元素在 HTML 中的顺序就是屏幕阅读器和键盘导航控件使用的顺序。<br>在示例中，当你使用 <code>row-reverse</code> 时，你首先在屏幕上看到 Jack 的名字，然后是 Jane、John 和 Jill。但是对于使用屏幕阅读器的人来说，他们将会按照 HTML 中的出现顺序而不是屏幕上的顺序来听到这些名字。在这种情况下，他们将首先听到 Jill 的名字，然后是 John、Jane 和 Jack。</p>
</blockquote>
<h3 id="3-2-flex-wrap-属性"><a href="#3-2-flex-wrap-属性" class="headerlink" title="3.2 flex-wrap 属性"></a>3.2 flex-wrap 属性</h3><p>有时，Flex 容器内的空间不足以容纳 Flex 子项, 在这种情况下，你可以使用 <code>flex-wrap</code> 属性来选择是让 Flex 子项溢出还是另起一行。</p>
<p>flex-wrap 属性接受以下任何值：</p>
<ul>
<li><code>nowrap</code>（默认值）：禁止 Flex 子项换行。</li>
<li><code>wrap</code>：允许 Flex 子项在新行开始。</li>
<li><code>wrap-reverse</code>：允许 Flex 子项在新行开始，并且新行的方向与 <code>wrap</code> 方向相反。</li>
</ul>
<p>要看到 <code>flex-wrap</code> 的效果，让我们向 <code>names-container</code> 添加超过四个的名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;names-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jill&quot;</span>&gt;</span>1. JILL<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span>&gt;</span>2. JOHN<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jane&quot;</span>&gt;</span>3. JANE<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>4. JACK<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;sara&quot;</span>&gt;</span>5. SARA<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;seth&quot;</span>&gt;</span>6. SETH<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;seal&quot;</span>&gt;</span>7. SEAL<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap;</span><br><span class="line">  <span class="comment">/* Other styles here... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flex-wrap: nowrap</code>: 这会禁止 Flex 子项换行。在这个例子中，由于空间不足，三个名字溢出容器。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-08.png"
                        alt="Flex Wrap 示例"
                 ></p>
<p><code>flex-wrap: wrap</code>: 当空间不足时，这会将 Flex 子项换行或推到下一行。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-09.png"
                        alt="Flex Wrap 示例"
                 ></p>
<p><code>flex-wrap: wrap-reverse</code>: 这会允许 Flex 子项在新行开始，并且新行的方向与 <code>wrap</code> 方向相反。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-10.png"
                        alt="Flex Wrap 示例"
                 ></p>
<h3 id="3-3-flex-flow-缩写属性"><a href="#3-3-flex-flow-缩写属性" class="headerlink" title="3.3 flex-flow 缩写属性"></a>3.3 flex-flow 缩写属性</h3><p><code>flex-flow</code> 属性是 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性的缩写。这意味着当你使用 <code>flex-flow</code> 时，只需要一行代码即可同时应用这两个属性。如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="comment">/* Other styles here... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* is equivalent to: */</span></span><br><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: column wrap;</span><br><span class="line">  <span class="comment">/* Other styles here... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-11.png"
                        alt="Flex Wrap 示例"
                 ></p>
<h3 id="3-4-justify-content-属性"><a href="#3-4-justify-content-属性" class="headerlink" title="3.4 justify-content 属性"></a>3.4 justify-content 属性</h3><p><code>justify-content</code> 属性处理 Flex 容器主轴上 Flex 子项的对齐方式。你可以使用它来处理主轴上空间的分配方式。该属性可以取以下任何值：</p>
<ul>
<li><code>flex-start</code>（默认值）：Flex 子项向主轴起点对齐。</li>
<li><code>flex-end</code>：Flex 子项向主轴终点对齐。</li>
<li><code>center</code>：Flex 子项居中对齐。</li>
<li><code>space-between</code>：Flex 子项平均分布，两端对齐。</li>
<li><code>space-around</code>：Flex 子项平均分布，每个项两侧留有空白。</li>
<li><code>space-evenly</code>：Flex 子项平均分布，所有项间均匀分布。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="comment">/* Other styles here... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>justify-content: flex-start</code>:这将把 Flex 子项放置在 <code>flex-direction</code> 的起始位置。如果主轴是水平的（<code>flex-direction</code> 的属性值是 row），它会将 Flex 子项对齐到左侧。如果主轴是垂直的（<code>flex-direction</code> 的属性值是 column），它会将 Flex 子项对齐到顶部。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-12.png"
                        alt="Justify Content 示例"
                 ></p>
<p><code>justify-content: flex-end</code> :这会将 Flex 子项放置在主轴的 flex-direction 的末尾。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-13.png"
                        alt="Justify Content 示例"
                 ></p>
<p><code>justify-content: center</code> :这会将 Flex 子项居中对齐。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-14.png"
                        alt="Justify Content 示例"
                 ></p>
<p><code>justify-content: space-between</code>: 这会将第一个 Flex 子项放置在主轴的起始位置，并将最后一个项放置在主轴的末尾。然后，主轴上的空间在这些元素之间均匀分布。(<code>space-between</code>并不改变元素本身大小，它的作用只是将元素之间的间距均匀划分了):</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-15.png"
                        alt="Justify Content 示例"
                 ></p>
<p><code>justify-content: space-around</code>: 这也会在 Flex 子项之间均匀分配空间。这里的关键区别在于，第一个项之前和最后一个项之后的空间是 Flex 子项之间空间的一半。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-16.png"
                        alt="Justify Content 示例"
                 ></p>
<p><code>justify-content: space-evenly</code>: 这会在 Flex 子项之间均匀分配空间。这意味着每项前后的空间都相同。（在 <code>space-between</code> 模式中，首项和末项在没有其他 CSS 设置的前提下，与 Flex 容器的左外边距&#x2F;右外边距为 0，即在 Flex 容器中与最左端和最右端“顶格”。而<code>space-evenly</code> 则是保证每一个 Flex 子项左侧和右侧的边距均是相等的，即 Flex 子项之间的间距和 Flex 子项与 Flex 容器边界的间距都相等，该模式下 Flex 子项与 Flex 容器的左右边界也存在间距。）</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-17.png"
                        alt="Justify Content 示例"
                 ></p>
<h3 id="3-5-align-items-属性"><a href="#3-5-align-items-属性" class="headerlink" title="3.5 align-items 属性"></a>3.5 align-items 属性</h3><p><code>align-items</code> 属性处理 Flex 子项在 Flex 容器交叉轴上的对齐方式。它可以采用以下任意值：</p>
<ul>
<li><code>stretch</code>（默认值）：默认值。Flex 子项拉伸以填充 Flex 容器。</li>
<li><code>flex-start</code>：Flex 子项向交叉轴起点对齐。</li>
<li><code>flex-end</code>：Flex 子项向交叉轴终点对齐。</li>
<li><code>center</code>：Flex 子项居中对齐。</li>
<li><code>baseline</code>：Flex 子项与容器基线对齐。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch;</span><br><span class="line">  <span class="comment">/* Other styles here... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>align-items: stretch</code>: 这会默认拉伸 Flex 子项以填充 Flex 容器。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-18.png"
                        alt="Align Items 示例"
                 ></p>
<p><code>align-items: flex-start</code>: 这会将 Flex 子项放置在交叉轴的起始位置。如果交叉轴是垂直的，它会将 Flex 子项放置在顶部。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-19.png"
                        alt="Align Items 示例"
                 ></p>
<p><code>align-items: flex-end</code>: 这会将 Flex 子项放置在交叉轴的末尾。如果交叉轴是垂直的，如下例所示， align-items: 它会将 Flex 子项放置在底部。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-20.png"
                        alt="Align Items 示例"
                 ></p>
<p><code>align-items: center</code>: 这会将 Flex 子项在交叉轴上居中对齐。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-21.png"
                        alt="Align Items 示例"
                 ></p>
<p><code>align-items: baseline</code>: 当你使用 baseline 值时，Flex 子项目的排列方式是使它们的基线对齐。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-22.png"
                        alt="Align Items 示例"
                 ></p>
<h3 id="3-6-align-content-属性"><a href="#3-6-align-content-属性" class="headerlink" title="3.6 align-content 属性"></a>3.6 align-content 属性</h3><p>当你有一个带有换行（或多个 Flex 行）的 Flex 容器时，你可能需要对这些行进行对齐以根据需要分配空间。这时你可以使用 align-content 。</p>
<p><code>align-content</code> 属性可以取以下任意值：</p>
<ul>
<li><code>stretch</code>（默认值）：默认值。Flex 行拉伸以填充 Flex 容器。</li>
<li><code>flex-start</code>：Flex 行向交叉轴起点对齐。</li>
<li><code>flex-end</code>：Flex 行向交叉轴终点对齐。</li>
<li><code>center</code>：Flex 行居中对齐。</li>
<li><code>space-between</code>：Flex 行平均分布，两端对齐。</li>
<li><code>space-around</code>：Flex 行平均分布，每个项两侧留有空白。</li>
<li><code>space-evenly</code>：Flex 行平均分布，所有项间均匀分布。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start;</span><br><span class="line">  <span class="comment">/* Other styles here... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中，<code>names-container</code>中有 11 个名字，并且<code>names-container</code>的 <code>flex-wrap</code> 值为 wrap。这意味着你可以应用 <code>align-content</code> 属性来改变 Flex 行的对齐方式。</p>
<p><code>align-content: stretch</code>:这会拉伸 Flex 行以填充 Flex 容器交叉轴内的空间。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-23.png"
                        alt="Align Content 示例"
                 ></p>
<p><code>align-content: flex-start</code>: 这将把 Flex 行放置在容器的交叉轴起始位置。例如，如果交叉轴像 <code>names-container</code> 一样是垂直的，它就会将 Flex 行放置在顶部。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-24.png"
                        alt="Align Content 示例"
                 ></p>
<p><code>align-content: flex-end</code>: 这将把 Flex 行放置在容器的交叉轴末尾。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-25.png"
                        alt="Align Content 示例"
                 ></p>
<p><code>align-content: center</code>: 这会将 Flex 行放置在容器的交叉轴中心位置。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-26.png"
                        alt="Align Content 示例"
                 ></p>
<p><code>align-content: space-between</code>: 这会将第一行放置在交叉轴的起始位置。它还会将最后一行放置在交叉轴的末尾位置。然后，交叉轴上的空间会均匀分配给这些行。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-27.png"
                        alt="Align Content 示例"
                 ></p>
<p><code>align-content: space-around</code>: 这也会在 Flex 行之间均匀分配空间。这里的主要区别在于，第一行之前和最后一行之后的空间是 Flex 行之间空间的一半。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-28.png"
                        alt="Align Content 示例"
                 ></p>
<p><code>align-content: space-evenly</code>: 这会在 Flex 行之间均匀分配空间。这意味着每行前后的空间都相同。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-29.png"
                        alt="Align Content 示例"
                 ></p>
<h3 id="3-7-place-content-属性"><a href="#3-7-place-content-属性" class="headerlink" title="3.7 place-content 属性"></a>3.7 place-content 属性</h3><p>如果你需要同时使用 <code>justify-content</code> 和 <code>align-content</code> 属性，你可以使用 <code>place-content</code> 缩写属性。它可以接受一个或两个值。当你给它一个单一值时，浏览器会为 <code>justify-content</code> 和 <code>align-content</code> 应用相同的值。当你为 <code>place-content</code> 提供两个值时，第一个值将用于 <code>align-content</code> ，第二个值将用于 <code>justify-content</code>。让我们看一个示例:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-end;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="comment">/* Other content */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* is equivalent to: */</span></span><br><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  place-<span class="attribute">content</span>: flex-end flex-start;</span><br><span class="line">  <span class="comment">/* Other content */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-30.png"
                        alt="Place Content 示例"
                 ></p>
<h2 id="4-Flex-子项属性"><a href="#4-Flex-子项属性" class="headerlink" title="4. Flex 子项属性"></a>4. Flex 子项属性</h2><p>Flex 容器的每个直接子元素都是 Flex 子项。Flexbox 还有一些属性，你可以应用到单个 Flex 子项上。它们包括以下内容：</p>
<ul>
<li><code>order</code> 属性：你可以使用 <code>order</code> 属性来控制 Flex 子项的显示顺序。默认情况下，Flex 子项按照它们在 HTML 中的顺序来显示。</li>
<li><code>align-self</code> 属性：你可以使用 <code>align-self</code> 属性来控制单个 Flex 子项的对齐方式。默认情况下，<code>align-items</code> 属性的值会应用到 Flex 子项上。</li>
<li><code>flex-grow</code> 属性：你可以使用 <code>flex-grow</code> 属性来控制 Flex 子项的扩展比例。默认情况下，Flex 子项的扩展比例为 0，即它们不会扩展。</li>
<li><code>flex-shrink</code> 属性：你可以使用 <code>flex-shrink</code> 属性来控制 Flex 子项的收缩比例。默认情况下，Flex 子项的收缩比例为 1，即它们会收缩以适应 Flex 容器。</li>
<li><code>flex-basis</code> 属性：你可以使用 <code>flex-basis</code> 属性来设置 Flex 子项的初始大小。默认情况下，Flex 子项的初始大小为 auto，即它们会根据内容的大小来确定大小。</li>
<li><code>flex</code> 属性：你可以使用 <code>flex</code> 属性来一次性设置 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 属性。</li>
</ul>
<h3 id="4-1-order-属性"><a href="#4-1-order-属性" class="headerlink" title="4.1 order 属性"></a>4.1 order 属性</h3><p>order 属性确定 Flex 子项的出现顺序。给这个属性的赋值必须是一个数字。一个数字较小的 Flex 子项将出现在数字较大的 Flex 子项之前。</p>
<p>在 HTML 代码中，四个名字的顺序如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;names-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jill&quot;</span>&gt;</span>1. JILL<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span>&gt;</span>2. JOHN<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jane&quot;</span>&gt;</span>3. JANE<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>4. JACK<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以使用 order 属性改变屏幕上的出现顺序。以下是没有 order 属性时它们的显示方式:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-31.png"
                        alt="Order 示例"
                 ></p>
<p>当你添加以下 order 属性时，它们的显示方式如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jill</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fe4f46</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#john</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fcd65c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jane</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00bab4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jack</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#003f54</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-32.png"
                        alt="Order 示例"
                 ></p>
<blockquote>
<p>‼️ 尽管屏幕上的出现顺序改变了，但 HTML 中的顺序保持不变。而屏幕阅读器使用的是 HTML 中的顺序。如果可能，最佳实践是在 HTML 中改变顺序，而不是使用 Flexbox 进行更改。</p>
</blockquote>
<h3 id="4-2-align-self-属性"><a href="#4-2-align-self-属性" class="headerlink" title="4.2 align-self 属性"></a>4.2 align-self 属性</h3><p>你可以使用 <code>align-self</code> 属性为一个 Flex 子项单独设置不同的对齐方式。它的工作方式与 <code>align-items</code> 属性相同。不同之处在于， <code>align-items</code> 适用于所有 Flex 子项，而 <code>align-self</code> 属性仅适用于特定项。 例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jill</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-33.png"
                        alt="Align Self 示例"
                 ></p>
<p>在这个示例中，<code>names-container</code> 的 <code>align-items</code> 属性设置为 <code>center</code>，这会使所有名字都居中对齐。但是使用 <code>align-self</code> 属性，你可以用 <code>flex-start</code> 将 Jill 的名字卡片对齐到顶部。</p>
<h3 id="4-3-flex-grow-属性"><a href="#4-3-flex-grow-属性" class="headerlink" title="4.3 flex-grow 属性"></a>4.3 flex-grow 属性</h3><p>当你将容器的 display 设置为 flex 时，通常会在排列项之后有一些额外的空间。请参阅下面的示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="comment">/* Other styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-34.png"
                        alt="Flex Grow 示例"
                 ></p>
<p>浏览器会将<strong>多余的空间</strong>视为 1 的值。这意味着当你为其中一个 Flex 子项的 <code>flex-grow</code> 设置为 0.5 时，浏览器会将剩余空间的一半添加到该项的大小中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#jill</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-35.png"
                        alt="Flex Grow 示例"
                 ></p>
<p>在这个示例中，Jill 的 <code>flex-grow</code> 属性设置为 0.5，这会使浏览器将剩余空间的一半添加到 Jill 的大小中。<code>flex-grow</code> 属性使 Jill 的大小大于其初始大小。</p>
<p>如果你只给一个 Flex 子项设置了 <code>flex-grow</code> 值为 1 ，浏览器将把所有额外的空间都分配给该项。下面两个代码片段对 Jill 的卡片具有相同的效果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#jill</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* is equivalent to: */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jill</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-36.png"
                        alt="Flex Grow 示例"
                 ></p>
<p>当你为多个元素添加 <code>flex-grow</code> 值会发生什么？浏览器将<strong>按比例</strong>为它们共享额外的空间。</p>
<p>例如，当你给 Jane 设置 <code>flex-grow</code> 为 3，给 Jack 设置 flex-grow 为 1 时，浏览器将以 3:1 的比例分享额外的空间。这意味着额外空间的总值变为 4（3+1）。Jane 将获得额外空间的 3&#x2F;4，而 Jack 将获得 1&#x2F;4, 如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-37.png"
                        alt="Flex Grow 示例"
                 ></p>
<h3 id="4-4-flex-shrink-属性"><a href="#4-4-flex-shrink-属性" class="headerlink" title="4.4 flex-shrink 属性"></a>4.4 flex-shrink 属性</h3><p><code>flex-shrink</code> 属性与 <code>flex-grow</code> 相反。当你希望在存在额外空间时增加 Flex 子项的大小时，你可以使用 <code>flex-grow</code>。但是，当 Flex 容器中的空间不足时，你可以使用 <code>flex-shrink</code> 来减小 Flex 子项的大小。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;numbers-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;three&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;four&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.numbers-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">  <span class="comment">/* Other styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#one</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fe4f46</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-38.png"
                        alt="Flex Shrink 示例"
                 ></p>
<p>在这个示例中，四个数字每个的宽度都设置为 150px（总共 600px）。但 <code>numbers-container</code> 的宽度只有 400px，这是不够的。卡片必须缩小以适应可用空间。数字 1 的 <code>flex-shrink</code> 的值为 2, 其他子项没有设置（默认值是 1），这意味着数字 1 在缩小时会以两倍于默认或其他设置较低的元素的比例进行收缩。</p>
<p><strong>如果你不希望一个 Flex 子项缩小怎么办？</strong>为了防止 Flex 子项收缩，给它一个 <code>flex-shrink</code> 值为 0。例如，当你为 Number 1 指定 <code>flex-shrink</code> 为 0 时，它将保持 150px 的宽度。其他 Flex 子项将缩小以适应剩余空间。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-39.png"
                        alt="Flex Shrink 示例"
                 ></p>
<h3 id="4-5-flex-basis-属性"><a href="#4-5-flex-basis-属性" class="headerlink" title="4.5 flex-basis 属性"></a>4.5 flex-basis 属性</h3><p>你可以使用 <code>flex-basis</code> 属性来设置特定 Flex 子项的默认长度。这取决于 <code>flex-direction</code> ，可以是宽度或高度。</p>
<ul>
<li>如果 <code>flex-direction</code> 是 <code>row</code> 或 <code>row-reverse</code> ，则 <code>flex-basis</code> 的值就成为 Flex 子项的初始宽度。</li>
<li>如果 <code>flex-direction</code> 是 <code>column</code> 或 <code>column-reverse</code> ，那么 <code>flex-basis</code> 的值就成为 Flex 子项的初始高度。</li>
</ul>
<p>例如:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="comment">/* Other styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jane</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-40.png"
                        alt="Flex Basis 示例"
                 ></p>
<p>在这个示例中，div 的高度设置为 20px。但 Jane 得到的 flex-basis 值为 60px。这意味着 Jane 的初始高度为 60px，而不是 20px。</p>
<p>下面是另一个示例。这次，<code>flex-direction</code> 是 row。这意味着 flex-basis 将设置 Flex 子项的宽度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="comment">/* Other styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jane</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">140px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-41.png"
                        alt="Flex Basis 示例"
                 ></p>
<p>在这个示例中，div 的宽度设置为 70px。但 Jane 得到的 flex-basis 值为 140px。这意味着 Jane 的初始宽度为 140px，而不是 70px。</p>
<h3 id="4-6-flex-缩写属性"><a href="#4-6-flex-缩写属性" class="headerlink" title="4.6 flex 缩写属性"></a>4.6 flex 缩写属性</h3><p>你可以使用 flex 作为 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 属性的缩写。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* is equivalent to: */</span></span><br><span class="line"><span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>flex-grow</code> 的值为 2，<code>flex-shrink</code> 的值为 0，<code>flex-basis</code> 的值为 50px。这等价于 <code>flex: 2 0 50px;</code>。</p>
<p><strong>值的顺序很重要</strong>。浏览器将第一个值分配给 <code>flex-grow</code>，第二个值分配给 <code>flex-shrink</code>，第三个值分配给 <code>flex-basis</code>。这意味着如果你给 flex 一个值为 2，浏览器将使用 2 作为 <code>flex-grow</code>。然后它将 <code>flex-shrink</code> 设置为 0，将 <code>flex-basis</code> 设置为 auto。</p>
<blockquote>
<p>💡 flex 的默认值是 1 0 auto。</p>
</blockquote>
<h2 id="5-一些-Flexbox-常见用例"><a href="#5-一些-Flexbox-常见用例" class="headerlink" title="5. 一些 Flexbox 常见用例"></a>5. 一些 Flexbox 常见用例</h2><h3 id="5-1-元素居中"><a href="#5-1-元素居中" class="headerlink" title="5.1 元素居中"></a>5.1 元素居中</h3><p>让许多前端开发人员头疼的问题之一是元素居中。 Flexbox 对此提供了一个完美的解决方案。</p>
<p>涉及两个步骤：</p>
<ol>
<li>通过将 <code>display</code> 设置为 <code>flex</code> 使父元素成为 Flex 容器。</li>
<li>将 <code>justify-content</code> 和 <code>align-items</code> 都设置为 <code>center</code>。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>JOHN<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="comment">/* Other Styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-42.png"
                        alt="Flexbox 居中示例"
                 ></p>
<p>无论你是试着居中文本、图像，还是整个导航栏，这都能完美运行。</p>
<h3 id="5-2-全屏布局"><a href="#5-2-全屏布局" class="headerlink" title="5.2 全屏布局"></a>5.2 全屏布局</h3><p>经典的<strong>全屏布局</strong>由顶部、底部和主体三部分组成，其特性为<strong>三部分左右满屏拉伸、顶部底部高度固定和主体</strong>高度自适应。该布局很常见，也是很多 Web 应用主体的主流布局。通常使用<code>&lt;header&gt;、&lt;footer&gt;和&lt;main&gt;</code>三个标签语义化排版，<code>&lt;main&gt;</code>内还可加入<code>&lt;aside&gt;</code>侧栏或其他语义化标签。</p>
<p>使用 flex 实现会非常简洁：<code>display:flex</code> 默认让子节点横向排列，需声明<code>flex-direction:column</code> 改变子节点排列方向为纵向排列；顶部与底部高度固定，主体声明 <code>flex:1</code> 自适应高度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fullscreen-layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fullscreen-layout</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f66</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">footer</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#66f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#3c9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-47.png"
                        alt="Flexbox 全屏布局示例"
                 ></p>
<p>⚠️ 若 <code>&lt;main&gt;</code> 需表现为可滚动状态，千万不要声明 <code>overflow:auto</code> 让容器自适应滚动，这样做有可能因为其他格式化上下文的影响而导致自适应滚动失效或产生其他未知效果。解决方案是在 <code>&lt;main&gt;</code> 中插入一个 <code>&lt;div&gt;</code> 并声明如下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fullscreen-layout</span> &#123;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">      <span class="attribute">overflow</span>: auto;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-两列布局"><a href="#5-3-两列布局" class="headerlink" title="5.3 两列布局"></a>5.3 两列布局</h3><p>经典的两列布局由左右两列组成，其特性为<strong>一列宽度固定、另一列宽度自适应和两列高度固定且相等</strong>。以下以左列宽度固定与右列宽度自适应为例，反之同理。</p>
<p>使用 flex 实现非常简洁。左列声明固定宽度，右列声明 <code>flex:1</code> 自适应宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two-column-layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two-column-layout</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="comment">/* 左列固定宽度 */</span></span><br><span class="line">  <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f66</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 右列自适应宽度 */</span></span><br><span class="line">  <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#66f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-48.png"
                        alt="Flexbox 两列布局示例"
                 ></p>
<h3 id="5-4-三列布局"><a href="#5-4-三列布局" class="headerlink" title="5.4 三列布局"></a>5.4 三列布局</h3><p>经典的三列布局由左中右三列组成，其特性为<strong>连续两列宽度固定、剩余一列宽度自适应和三列高度固定且相等</strong>。以下以左中列宽度固定与右列宽度自适应为例，反之同理。整体的实现原理与上述两列布局一样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three-column-layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.three-column-layout</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="comment">/* 左中列固定宽度 */</span></span><br><span class="line">  <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f66</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#66f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 右列自适应宽度 */</span></span><br><span class="line">  <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#3c9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-49.png"
                        alt="Flexbox 三列布局示例"
                 ></p>
<h3 id="5-5-圣杯布局-双飞翼布局"><a href="#5-5-圣杯布局-双飞翼布局" class="headerlink" title="5.5 圣杯布局&#x2F;双飞翼布局"></a>5.5 圣杯布局&#x2F;双飞翼布局</h3><p>经典的<strong>圣杯布局</strong>与<strong>双飞翼布局</strong>都是由左中右三列组成，其特性为<strong>左右两列宽度固定、中间一列宽度自适应和三列高度固定且相等</strong>。其实也是上述两列布局与三列布局的变体，整体的实现原理与上述 N 列布局一样，可能就是一些细节需注意。</p>
<p>圣杯布局与双飞翼布局大体相同但也存在一点不同，区别在于<strong>双飞翼布局</strong>中列需加入一个子节点。在常规实现方式中也是在中列中做文章：如何使中列内容不被左右列遮挡。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grail-layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grail-layout</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f66</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#3c9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#66f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/posts/css-flex/css-flex-50.png" alt="Flexbox 圣杯布局/双飞翼布局示例"></p>
<h2 id="6-Flexbox-间隙"><a href="#6-Flexbox-间隙" class="headerlink" title="6. Flexbox 间隙"></a>6. Flexbox 间隙</h2><p>你可以使用 gap 属性来调整 Flex 子项之间的间距。gap 可以取两个值：第一个值用于行之间的间距，第二个值用于列之间的间距。</p>
<blockquote>
<p>注意：gap 属性应用于 Flex 容器，而不是 Flex 子项。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">50px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="comment">/* row-gap column-gap */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-43.png"
                        alt="Flexbox 间隙示例"
                 ></p>
<p>如果你想要的行和列之间的间距相同，你可以使用单个值。浏览器将为行和列都应用相同的值。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="comment">/* row-gap column-gap */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-44.png"
                        alt="Flexbox 间隙示例"
                 ></p>
<p>如果你需要仅在行之间应用特定的间隙值，你还可以使用属性 <code>row-gap</code> 。如果你需要仅在列之间添加间隙，则使用 <code>column-gap</code> 。例如：仅在行之间添加间隙：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">row-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/* other styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-45.png"
                        alt="Flexbox 间隙示例"
                 ></p>
<p>仅在列之间添加间隙：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.names-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/* other styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/../images/posts/css-flex/css-flex-46.png"
                        alt="Flexbox 间隙示例"
                 ></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习 JavaScript 系列（一)：作用域</title>
    <url>/2024/03/01/advance-javascript/series-01-scope/</url>
    <content><![CDATA[<h2 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1. 什么是作用域?"></a>1. 什么是作用域?</h2><p>几乎所有的编程语言最基本的功能之一就是能够存储变量中的值，并且能在之后对这个值进行访问和修改。正是这种储存和访问变量的值的能力将<strong>状态</strong>引入到了程序中。</p>
<p>但是将变量引入程序会引起几个有意思的问题，也是需要我们认真思考的：这些变量<strong>住在</strong>哪里？或者说它们存储在哪里？更重要的是，程序在需要它们的时候如何找到它们？</p>
<h3 id="1-1-Javascript-的编译原理"><a href="#1-1-Javascript-的编译原理" class="headerlink" title="1.1 Javascript 的编译原理"></a>1.1 Javascript 的编译原理</h3><p>我们经常将 Javascript 归类为<strong>动态</strong>或者<strong>解释型</strong>语言，但是实际上 Javascript 是一门<strong>编译型</strong>语言。但是与传统的编译语言不同，Javascript <strong>不是</strong>提前编译的，编译的结果也不能在分布式系统中进行移植。</p>
<p>在传统编译语言的流程中，程序中的一段源代码在执行<strong>之前</strong>会经历三个步骤，统称为<strong>编译</strong>：</p>
<ol>
<li><strong>分词&#x2F;词法分析</strong>（Tokenizing&#x2F;Lexing）<br>这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为<strong>词法单元</strong>（token）。</li>
<li><strong>解析&#x2F;语法分析</strong>（Parsing）<br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，这个树被称为<strong>抽象语法树</strong>（Abstract Syntax Tree，AST）。</li>
<li><strong>代码生成</strong>（Code Generation）<br>这个过程是将 AST 转换为可执行代码的过程。</li>
</ol>
<blockquote>
<p>💡 与其他语言不同，Javascript 的编译过程不是发生在构建之前，大部分情况下是发生在代码执行前的几微秒，简单的说，任何 Javascript 代码片段在执行前都要进行编译（通常就在执行前）。</p>
</blockquote>
<h3 id="1-2-作用域"><a href="#1-2-作用域" class="headerlink" title="1.2 作用域"></a>1.2 作用域</h3><p>在理解作用域之前，我们先来介绍几个相关的概念：</p>
<ul>
<li><strong>引擎</strong>：从头到尾负责整个 Javascript 程序的编译和执行过程。</li>
<li><strong>编译器</strong>：引擎的好朋友之一，负责语法分析以及代码生成等脏活累活。</li>
<li><strong>作用域</strong>：引擎的另外一个好朋友，负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li>
</ul>
<p>接下来我们分析一下<code>var a = 2</code>这段代码在引擎、编译器以及作用域中是如何运行的。</p>
<p>你很可能认为这是一句声明，翻译成我们人类的语言就是：“为一个变量分配内存，将其命名为 a，然后将值 2 保存进这个变量（然而这并不完全正确）”。但是引擎却不这么看。事实上，引擎认为这里有连两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。下面我们将<code>var a = 2</code>分解,看看引擎和它的朋友们是如何协同工作的。</p>
<p>编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期有所不同。</p>
<p>事实上编译器会进行如下处理：</p>
<ol>
<li>遇到<code>var a</code>，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理<code>a = 2</code>这个赋值操作。引擎<strong>运行时</strong>会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量，直到到达最外层的作用域（也就是全局作用域）为止。</li>
<li>如果引擎最终找到了 a，就会将 2 赋值给它。否则引擎就会抛出一个异常。</li>
</ol>
<p><strong>总结：</strong> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在当前作用域中查找该变量，如果找到就会对其进行赋值。</p>
<h3 id="1-3-作用域嵌套"><a href="#1-3-作用域嵌套" class="headerlink" title="1.3 作用域嵌套"></a>1.3 作用域嵌套</h3><p>我们知道，作用域是<strong>根据名称查找变量的一套规则</strong>，它用于确定当前执行的代码对变量的访问权限。实际情况中，通常需要同时顾及几个作用域。</p>
<p>当一个块或者函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，<strong>引擎</strong>就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的全局作用域为止。</p>
<p>考虑以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，函数 foo 嵌套在全局作用域中，而变量 b 也在全局作用域中声明。当 foo 函数执行时，它会在自己的作用域中查找变量 b，但找不到，因此会继续查找外层的全局作用域，找到变量 b，并将其赋值给 a。</p>
<p>让我们把这段代码形象化的用<strong>引擎</strong>和<strong>作用域</strong>之间的对话来描述：</p>
<ul>
<li>引擎：foo 的作用域兄弟，你见过变量 b 吗？我需要对它进行 RHS 引用查询。</li>
<li>作用域：听都没听过，走开。</li>
<li>引擎：foo 的上一级作用域兄弟，咦？有眼不识泰山了，原来你是全剧作用域大哥，太好了。你见过变量 b 吗？我需要对它进行 RHS 引用查询。</li>
<li>作用域：当然了，给你吧。</li>
</ul>
<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找，如果找不到就会向上一级作用域继续查找。当抵达最外层的全局作用域时，无论找到与否都会停止。</p>
<blockquote>
<p>💡 关于 LHS 查询和 RHS 查询：RHS 查询与简单的查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其进行赋值。在概念上最好理解为：赋值操作的目标是谁？（LHS）。谁是赋值操作的源头？（RHS）。</p>
</blockquote>
<h3 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h3><p>为什么区分<code>LHS</code>和<code>RHS</code>很重要？</p>
<p>因为变量在还没有声明（在任何作用域中都无法找到该变量）时，这两种查询的行为是不一样的。考虑如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，第一次对 b 进行的 RHS 查询是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。</p>
<p>如果 RHS 查询在所有嵌套的作用域中都无法找到所需的变量，<strong>引擎</strong>就会抛出<code>ReferenceError</code>异常。请牢记，<code>ReferenceError</code>是一种非常重要的<strong>运行时</strong>异常类型。</p>
<p>相较之下，当引擎执行 LHS 查询时，如果一直查询到了顶层作用域（全局作用域）中仍然无法找到目标变量，<strong>全局作用域中</strong>就会创建一个具有改名称的变量，并将其返还给<strong>引擎</strong>，前提是程序运行在非<strong>严格模式</strong>下。</p>
<p>ES5 引入了“严格模式”，严格模式禁止自动或者隐式地创建全局变量。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，而是引擎会抛出同 RHS 查询失败时类似的<code>ReferenceError</code>异常。</p>
<p>此外，如果 RHS 查询找到了一个变量，但是当你尝试对这个变量的值进行不合理的操作时，比如试图对一个非函数类型的值进行函数调用，或者对一个<code>null</code>或者<code>undefined</code>值进行属性访问，引擎也会抛出另外一种类型的异常，叫做<code>TypeError</code>。</p>
<blockquote>
<p>💡 <code>ReferenceError</code>同作用域判别失败相关，而<code>TypeError</code>则代表了作用域判别成功了，但是对变量的操作是非法或者不合理的。</p>
</blockquote>
<h2 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2. 词法作用域"></a>2. 词法作用域</h2><p>我们将<strong>作用域</strong>定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p>
<p>作用域共有两种主要的工作类型，第一种是最为普遍的，被大多数编程语言所采用，叫做<strong>词法作用域</strong>（Lexical Scope）。另外一种叫做<strong>动态作用域</strong>（Dynamic Scope），它是根据运行时环境的变化而变化的作用域。</p>
<h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h3><p>大部分标准语言编译器的第一个工作阶段叫做词法分析（也叫做单词化&#x2F;Tokenizing），词法化的过程就是将源代码字符串分解成一个个的词法单元（Token）。</p>
<p>简单的说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在<strong>写代码时</strong>将变量和块作用域写在哪里来决定的，因此，当词法分析器处理代码时会保持作用域不变。</p>
<p>举个例子，考虑以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>); <span class="comment">// 2 4 12</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中一共有三个逐级嵌套的作用域：</p>
<ul>
<li>❶ 全局作用域（Global Scope），其中只有一个标识符： foo;</li>
<li>❷ 函数 foo 的作用域（Function Scope），其中有三个标识符：a, b, bar;</li>
<li>❸ 函数 bar 的作用域（Function Scope）,其中有两个标识符：c。</li>
</ul>
<p><strong>作用域查找会在找到第一个匹配的标识符时停止。</strong>在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的同名标识符）。作用域查找始终从<strong>运行时</strong>所处的最内部作用域开始，逐级向外或者向上进行，直到遇见第一个匹配的标识符为止。</p>
<blockquote>
<p>⚠️ 无论函数在<strong>哪里</strong>被调用，也无论它<strong>如何</strong>被调用，它的词法作用域都只有函数<strong>被声明时</strong>所处的位置决定。</p>
</blockquote>
<h3 id="2-2-欺骗词法作用域"><a href="#2-2-欺骗词法作用域" class="headerlink" title="2.2 欺骗词法作用域"></a>2.2 欺骗词法作用域</h3><p>如果词法作用域完全由写代码期间函数所声明的位置决定，有没有一种方法可以在<strong>运行时</strong>来<strong>修改</strong>（或者说“欺骗”）词法作用域呢？</p>
<p>JavaScript 中有两种机制可以实现这个目的，但是社区普遍认为在代码中使用这两种机制并不是什么好主意，最重要的一点是：<strong>欺骗词法作用域会导致性能下降</strong>。</p>
<h4 id="2-2-1-eval"><a href="#2-2-1-eval" class="headerlink" title="2.2.1 eval"></a>2.2.1 eval</h4><p><code>eval()</code>函数可以接受一个字符串作为参数，并将其中的内容视为<strong>好像在书写时就存在于程序中的那个位置一样</strong>。换句话说，可以在你写的代码中用程序在<strong>运行时</strong>生成代码并运行，就好像代码就是写在那个位置一样。</p>
<p>在执行<code>eval()</code>之后的代码时，引擎并不知道也不在意前面的代码是以动态的形式插入进来的，引擎只会如往常一样进行词法作用域查找。</p>
<p>考虑一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">str, a</span>) &#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;var b = 3;&#x27;</span>, <span class="number">1</span>); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>eval()</code>函数将字符串<code>var b = 3</code>作为代码插入到了函数 <code>foo</code> 中，引擎会将其视为在函数 <code>foo</code> 声明时就存在的那个位置。</p>
<p>因此，在执行<code>eval()</code>之后的代码时，引擎会认为变量 b 的值是 3，而不是 2, 这段代码对已经存在的<code>foo</code>的词法作用域进行了修改。</p>
<p>默认情况下，如果<code>eval()</code>中执行的代码包含一个或者多个声明（无论是变量还是函数），就会对<code>eval()</code>所处的词法作用域进行修改。无论在何种情况下，<code>eval()</code>都可以在<strong>运行时</strong>修改书写期的词法作用域。</p>
<h4 id="2-2-2-with"><a href="#2-2-2-with" class="headerlink" title="2.2.2 with"></a>2.2.2 with</h4><p>JavaScript 中另外一个用来欺骗词法作用域的功能是<code>with</code><strong>关键字</strong>，<code>with</code>被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单调乏味的重复引用 “obj”</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">3</span>;</span><br><span class="line">obj.<span class="property">c</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简洁的使用 “with” 关键字</span></span><br><span class="line"><span class="title function_">with</span> (obj) &#123;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">  c = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这实际上并不仅仅是为了方便的访问对象属性，比如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="title function_">with</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(o1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(o2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2 -- 不好，a被泄漏到了全局作用域上了！</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，当我们将 o1 传递进去，<code>a = 2</code>赋值操作通过 LHS 查询找到了<code>o1.a</code>并将 2 赋值给它，这在随后的<code>console.log(o1.a)</code>可以体现。而当 o2 被传递进去时，o2 并没有 a 属性，因此<code>a = 2</code>的赋值操作通过 LHS 查询失败，引擎会在全局作用域中创建一个新的变量<code>a</code>，并将 2 赋值给它。而 o2 并没有<code>a</code>属性，因此<code>console.log(o2.a)</code>会返回<code>undefined</code>。</p>
<p><code>with</code>可以将一个没有或者有多个属性的对象处理为一个<strong>完全隔离</strong>的词法作用域，因此，这个对象的属性也会被处理为<strong>定义在这个词法作用域中的词法标识符</strong>。</p>
<p><code>eval()</code>函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而<code>with</code>实际上是根据你传递给它的对象<strong>凭空创建了一个全新的词法作用域。</strong></p>
<blockquote>
<p>⚠️ 虽然<code>eval()</code>和<code>with</code>可以欺骗词法作用域，但是它并不推荐使用，因为它会导致代码难以理解和维护。另外一个不推荐使用的原因是会被严格模式所影响。严格模式下<code>with</code>被完全禁止，而<code>eval()</code>在严格模式下也会被禁止。</p>
</blockquote>
<h4 id="2-2-3-性能"><a href="#2-2-3-性能" class="headerlink" title="2.2.3 性能"></a>2.2.3 性能</h4><p>为什么说<code>eval()</code>和<code>with</code>会导致性能下降呢？</p>
<p>JavaScript 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行<strong>静态分析</strong>，并预先确定所有变量和函数的定义位置，才能在执行过程中（运行时）快速的找到标识符。</p>
<p>但是如果引擎在执行过程中发现了<code>eval()</code>或者<code>with</code>，它只能简单的<strong>假设</strong>所有关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道<code>eval()</code>会接受到什么样的代码，运行这些代码又会对作用域进行什么修改，也无法知道传递给<code>with</code>用来创建的新的词法作用域的对象内容是什么。</p>
<p>最悲观的情况是如果出现了<code>eval()</code>或者<code>with</code>，所有的优化肯能都是无意义的，因此最佳实践就是不要使用它们。</p>
<h2 id="3-函数作用域和块作用域"><a href="#3-函数作用域和块作用域" class="headerlink" title="3. 函数作用域和块作用域"></a>3. 函数作用域和块作用域</h2><p>我们可以把作用域理解为一个封闭的盒子或者一个气泡，它们可以嵌套，每个盒子（气泡）里包含了标识符（变量和函数），但是，究竟是什么生成了一个新的盒子？只有函数会生成新的盒子吗？JavaScrip 其他结构能生成作用域气泡吗？</p>
<h3 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a>3.1 函数中的作用域</h3><p>JavaScript 具有基于函数的作用域，每声明一个函数都会为其<strong>自身</strong>创建一个作用域气泡，而其他结构都不会创建作用域气泡。但事实上这不完全正确。考虑以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// more code here</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，函数<code>foo</code>的作用域气泡中包含了标识符 a、b、bar 和 c。无论标识符声明出现在作用域的何处，这个标识符所代表的变量或者函数都将附属域所处作用域的气泡中。</p>
<p>函数<code>bar</code>拥有自己的作用域气泡，全局作用域也有自己的作用域气泡，它只包含标识符 <code>foo</code>。由于标识符 a、b、bar 和 c，都附属于<code>foo</code>的作用域气泡，因此无法从外部对它们进行访问。也就是说无法从全局作用域中访问它们，下面的代码会导致<code>ReferenceError</code>异常：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>但是这些标识符可以被<code>foo</code>内部的代码访问到，也可以被<code>bar</code>内部的代码访问到（前提是<code>bar</code>内部没有声明同名的标识符）。</p>
<p>总结一下：函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（在嵌套的作用域中也可以使用）。</p>
<h3 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h3><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但是反过来也可以这么想：从所写的代码中挑选出任意一个片段，然后用函数声明对它进行包装，实际上就是把这段代码<strong>隐藏</strong>起来了。</p>
<p>实际产生的结果就是在这段代码的周围建立了一个作用域气泡（盒子），这段代码中的任何声明（变量或函数）都将绑定在这个新创建的作用域气泡中，而不是先前所在的作用域中，外部代码无法访问到这些变量。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域“隐藏”它们。</p>
<h4 id="3-2-1-最小授权原则"><a href="#3-2-1-最小授权原则" class="headerlink" title="3.2.1 最小授权原则"></a>3.2.1 最小授权原则</h4><p>隐藏变量和函数是一个非常有用的技术。在<strong>最小授权（也叫最小暴露）原则</strong>中，在软件设计时，应该最小限度的暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或者对象的 API 设计。</p>
<p>如果所有变量和函数都在全局作用域中，当然可以在所有内部嵌套的作用域中都访问到它们，但这样也会破坏最小暴露原则，因为可能活暴露过多的变量或函数，而它们本该是私有的。举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  b = a + <span class="title function_">doSomethingElse</span>(a * <span class="number">2</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在这个代码片段中，变量<code>b</code>和函数<code>doSomethingElse</code>应该是<code>doSomething()</code>函数内部实现的“私有”内容。给予外部作用域对它们的访问权限不仅没有必要，而且可能是危险的，因为它们可能被有意或者无意地以非预期的方式使用，从而导致超出了<code>doSomething()</code>的适用条件。更“合理”的设计是把它们隐藏在<code>doSomething()</code>的内部，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = a + <span class="title function_">doSomethingElse</span>(a * <span class="number">2</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-规避冲突"><a href="#3-2-2-规避冲突" class="headerlink" title="3.2.2 规避冲突"></a>3.2.2 规避冲突</h4><p>“隐藏”作作用域中的变量和函数的另外一个好处是：可以<strong>避免同名标识符之间的冲突。</strong> 两个标识符可能名字相同但是用途不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    i = <span class="number">3</span>; <span class="comment">// 此处会修改下面for循环中的i的值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">bar</span>(i * <span class="number">2</span>); <span class="comment">// 糟糕，无限循环了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p><code>for</code> 循环中的<code>var i = 0</code> 声明了一个变量 i，它位于<code>foo</code>的作用域中，<code>bar</code>函数内部的赋值表达式 <code>i = 3</code>,首先会在当前<code>bar</code>的作用域中查找 i，由于<code>bar</code>内部没有声明 i，因此会继续向上查找，在<code>foo</code>的作用域中查找了 i，于是 i 的值被修改为 3，因此 bar 函数里的这个对 i 的赋值操作实际上修改了 for 循环中的 i 的值，因此导致无限循环。</p>
<p>其实<code>bar()</code>内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，甚至同样适用<code>var i = 3;</code>也可以，由于同名的标识符会产生“遮蔽效应”，因此<code>bar()</code>函数使用的是自己内部作用域中的 i， 而不会修改外层<code>foo()</code>函数中的 i。</p>
<h4 id="3-2-3-全局命名空间"><a href="#3-2-3-全局命名空间" class="headerlink" title="3.2.3 全局命名空间"></a>3.2.3 全局命名空间</h4><p>变量冲突的一个典型的例子存在于全局作用域中。尤其是当程序加载了第三方库时，如果第三方库没有妥善的将内部的私有变量或函数隐藏起来，就会很容易引发冲突。</p>
<p>因此这些第三方库通常会在全局作用域中声明一个<strong>名字足够独特的变量</strong>，通常是一个对象。这个对象被用作库的<strong>命名空间</strong>，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符直接暴露在顶级的词法作用域中。</p>
<p>举个例子，jQuery 库的命名空间是<code>$</code>，它将自己的所有功能都绑定在这个对象上，而不将自己的标识符直接暴露在全局作用域中。</p>
<h3 id="3-3-函数作用域"><a href="#3-3-函数作用域" class="headerlink" title="3.3 函数作用域"></a>3.3 函数作用域</h3><p>我们知道，在任意的代码片段外部添加包装函数，可以将内部的变量和函数“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这种技术虽说可以解决一些问题，但是并不理想。</p>
<ul>
<li>首先你必须声明一个函数<code>foo</code>，这意味着<code>foo</code>这个名字本身就“污染”了所在的作用域；</li>
<li>其次你必须显式的通过函数名<code>foo()</code>调用这个函数，才能运行里面的代码。</li>
</ul>
<p>如果函数不需要函数名，或者说至少函数名不会污染所在的作用域，并且能够自动运行就好了。JavaScript 提供了一种方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，函数声明被（）包裹了起来，这是一个非常重要的区别，此时函数会被当作<strong>表达式</strong>而不是一个标准的函数声明来处理。函数声明和函数表达式最重要的区别是<strong>它们的名称标识符将会绑定在何处</strong>。</p>
<p>比较一下之前的两个代码片段，第一个片段中的<code>foo</code>被绑定在声明它的那个作用域，也就是全局作用域，因此我们可以直接通过<code>foo()</code>来调用它，而第二个片段中的<code>foo</code>被绑定在一个匿名函数表达式自身的函数中，而不是所在作用域中。</p>
<p>换句话说，<code>(function foo() &#123;...&#125;)</code>作为函数表达式意味着<code>foo</code>只能在…所代表的位置中被访问，外部作用域则不行。标识符<code>foo</code><strong>隐藏在自身中</strong>意味着不会非必要的污染外部作用域。</p>
<h4 id="3-3-1-匿名和具名函数表达式"><a href="#3-3-1-匿名和具名函数表达式" class="headerlink" title="3.3.1 匿名和具名函数表达式"></a>3.3.1 匿名和具名函数表达式</h4><p>先来看一下这个代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>注意我们传递给<code>setTimeout()</code>的第一个参数是一个函数表达式，而且它没有函数名，这叫做<strong>匿名函数表达式</strong>。</p>
<blockquote>
<p>⚠️ 函数表达式可以是匿名的，而函数声明则必须有函数名。</p>
</blockquote>
<p>匿名函数尽管写起来简单快捷，但是有几个缺点需要考虑：</p>
<ul>
<li>匿名函数在栈追踪中不会显示出有意义的函数名，因此使得调试变得困难；</li>
<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的<code>arguments.callee</code>，比如在递归中，另外一个函数需要引用自身的例子是在事件触发后事件监听器需要解绑自身；</li>
<li>匿名函数省略了对于代码可读性&#x2F;可理解性很重要的函数名，使得代码可读性变差。</li>
</ul>
<p>因此，始终给函数表达式取一个有意义的名字是一个最佳实践。</p>
<h4 id="3-3-2-立即执行函数表达式"><a href="#3-3-2-立即执行函数表达式" class="headerlink" title="3.3.2 立即执行函数表达式"></a>3.3.2 立即执行函数表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>我们已经知道，函数被包裹在<code>()</code>中，意味着它成为了一个表达式，通过在末尾加上<code>()</code>，可以让函数立即执行。第一个<code>()</code>将函数变成表达式，第二个<code>()</code>立即执行了这个函数。社区将此种模式称为<strong>立即执行函数表达式</strong>（Immediately-Invoked Function Expression，IIFE）。</p>
<p>IIFE 的另外一个非常普遍的进阶用法是<strong>把它们当作函数调用并传递参数进去</strong>。举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"><span class="variable language_">global</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)(<span class="variable language_">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这个模式的另外一个应用场景是解决<code>undefined</code><strong>标识符</strong>的默认值被错误覆盖导致的异常。讲一个参数命名为<code>undefined</code>但是在对应的位置不传入任何值，这样就可以保证在代码块种<code>undefined</code>标识符的值真的就是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>; <span class="comment">// 给程序的其他部分代码挖了一个大坑！千万不要这么做！</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"><span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Undefined is safe here!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="3-4-块作用域"><a href="#3-4-块作用域" class="headerlink" title="3.4 块作用域"></a>3.4 块作用域</h3><p>除 JavaScript 外的很多编程语言都支持块作用域，即使你对块作用域不是很了解，但是下面的代码你一定写过不少：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 for 循环的头部直接声明了变量 i，通常来说我们可能只是想在 for 循环内部的上下文中使用这个变量，但是却忽略了一个事实：<strong>这个变量 i 实际上会被绑定在外部作用域中（函数或者全局作用域），也就是 for 循环所在的作用域中而不是内部。</strong></p>
<p>这就是块作用域的用处。<strong>变量的声明应该距离使用的地方越近越好，并且最大限度的本地化。</strong>举一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> bra = foo * <span class="number">2</span>;</span><br><span class="line">  bar = <span class="title function_">something</span>(bar);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码的组织方式可以看出来<code>bar</code>仅在<code>if</code>声明的上下文中使用，因此上面的代码片段试图在<code>if</code>块内部声明<code>bar</code>变量。但是，当使用<code>var</code>声明<code>bra</code>变量时，它写在哪里都是一样的，因为它们最总都会被绑定在外部作用域中。</p>
<p>块作用域可以进一步扩展之前提到的<strong>最小暴露原则</strong>，将代码从在函数中“隐藏”信息扩展为在块中“隐藏”信息。再考虑下之前的代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要把一个只在<code>for</code>循环内部使用的变量 i 污染到整个函数作用域中呢？</p>
<h4 id="3-4-1-块作用域-with"><a href="#3-4-1-块作用域-with" class="headerlink" title="3.4.1 块作用域-with"></a>3.4.1 块作用域-with</h4><p>我们之前讨论过<code>with</code>关键字，它不仅仅是一个难以理解的结构，同时也是块作用域的一个例子，使用<code>with</code>从对象中创建的作用域仅在<code>with</code>声明中有效。</p>
<h4 id="3-4-2-块作用域-try-catch"><a href="#3-4-2-块作用域-try-catch" class="headerlink" title="3.4.2 块作用域-try&#x2F;catch"></a>3.4.2 块作用域-try&#x2F;catch</h4><p>很少有人注意到 JavaScript 的 ES3 规范中规定的<code>try/catch</code>的<code>catch</code>分句会创建一个块作用域，<strong>其中声明的变量仅在<code>catch</code>内部有效。</strong> 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">undefined</span>(); <span class="comment">// 引发一个错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// ReferenceError: err is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-3-块作用域-let"><a href="#3-4-3-块作用域-let" class="headerlink" title="3.4.3 块作用域-let"></a>3.4.3 块作用域-let</h4><p>ES6 引入了<code>let</code>关键字，提供了除了<code>var</code>之外的另一种变量声明的方式。<code>let</code>关键字可以<strong>将变量绑定到所在的任意作用域中</strong>，通常是<code>&#123;...&#125;</code>内部。换句话说，<code>let</code>为其声明的变量<strong>隐式地劫持了</strong>所在的块作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">  bar = <span class="title function_">something</span>(bar);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure>

<p>用<code>let</code>将变量附加在一个已经存在的块作用域上的行为是<strong>隐式的</strong>。此外关于声明提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内，而不管它在代码中出现的位置。但是<strong>使用<code>let</code>声明的变量不会被提升</strong>，声明的代码被运行之前，声明并不“存在”。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(1) 垃圾收集</strong><br>另一个关于块作用域非常有用的原因和闭包及内存垃圾回收机制有关， 考虑以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这是 doSomething() 函数的作用域</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with data</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> someReallyBigData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">join</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="title function_">process</span>(someReallyBigData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myBtn&#x27;</span>);</span><br><span class="line">  btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">    <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure>

<p>观察一下<code>doSomething</code>的作用域中都有哪些变量？答案是：process 函数、someReallyBigData、btn、click 函数。<code>click</code>函数的点击并不需要 someReallyBigData，理论上这意味着当 <code>process(someReallyBigData)</code>执行完毕后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 <strong>click 函数形成了一个覆盖整个作用域（也就是 doSomething 函数的作用域）的闭包</strong>，在<code>doSomething</code>函数执行完毕后，click 函数的引用依然存在，因此 JavaScript 引擎极有可能依然保存着这个数据。</p>
<p>块作用域可以打消这种顾虑，使引擎清楚的知道没有必要继续保存 someReallyBigData 了，让我们稍微调整下上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这是 doSomething() 函数的作用域</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with data</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这个块中定义的内容完事以后可以销毁</span></span><br><span class="line">    <span class="keyword">var</span> someReallyBigData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">join</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="title function_">process</span>(someReallyBigData);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myBtn&#x27;</span>);</span><br><span class="line">  btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">    <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure>

<p><strong>(2) let 循环</strong></p>
<p>一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>for 循环头部使用 let 来定义 i，这样做不仅将 i 绑定到了 for 循环的块中，事实上它也将 i <strong>重新绑定</strong>到了循环的<strong>每一个迭代</strong>中，确保使用上一个循环迭代结束时的值重新进行赋值。</p>
<p>让我们换一种方式来详细解释一下每次<strong>迭代</strong>时的<strong>重新绑定</strong>行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = j; <span class="comment">// 每次迭代重新绑定</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 let 声明的变量附属于一个新的作用域而不是当前的函数作用域，也不属于全局作用域。考虑一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(baz); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码等同于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里依然可以访问到上面在foo内部定义的bar变量</span></span><br><span class="line"><span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(baz); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果使用 let 来定义变量 bar 则有些不同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line">baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">    <span class="comment">// 如果你要移动这块代码则必须连同上面的 let bar 声明一起移动</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(baz); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-const"><a href="#3-4-4-const" class="headerlink" title="3.4.4 const"></a>3.4.4 const</h4><p>除了 let 关键字，ES6 还引入了 const 关键字，同样可以用来创建块作用域变量，但其值是固定的（常量），之后任何试图修改其值的操作都会引起错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">3</span>; <span class="comment">// 此常量b只包含在if块中</span></span><br><span class="line"></span><br><span class="line">  a = <span class="number">4</span>; <span class="comment">// 正常修改</span></span><br><span class="line">  b = <span class="number">5</span>; <span class="comment">// 错误，不能修改常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习 JavaScript 系列（二)：闭包</title>
    <url>/2024/04/12/advance-javascript/series-02-closure/</url>
    <content><![CDATA[<p>闭包是 JavaScript 这门语言中一个非常重要但又难以掌握，近乎<strong>神话</strong>的概念。关于闭包的深入理解，我们借用一下 Crockford 的话：<strong>“魔术师的幕后藏着一个人，我们将要揭开它的伪装。”</strong></p>
<p>首先请牢记一个秘诀：<strong>JavaScript 中闭包无处不在，你只需要能够识别并拥抱它</strong>。闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它而有意的创建闭包。闭包的创建和使用在你的日常代码中随处可见，你<strong>缺少</strong>的只是根据你自己的意愿来识别、拥抱和影响闭包的<strong>思维环境</strong>。</p>
<h2 id="1-从问题和疑惑开始"><a href="#1-从问题和疑惑开始" class="headerlink" title="1. 从问题和疑惑开始"></a>1. 从问题和疑惑开始</h2><p>首先来直接了当的贴出闭包的定义：当函数可以<strong>记住并访问所在的词法作用域</strong>时，就产生了闭包，即使函数是在当前词法作用域之外执行。来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>基于词法作用域的查找规则，函数<code>bar()</code>内部可以<strong>访问</strong>外部作用域（也就是 foo 函数的作用域）中的变量<code>a</code>(这个例子中的是一个 RHS 的引用查询)。</p>
<p>请问这个是闭包吗？</p>
<p>技术上来讲，<strong>也许是</strong>。但是根据刚才的定义，<strong>确切地说并不是</strong>。我认为最准确的用来解释<code>bar()</code>内部对<code>a</code>的引用的方法是词法作用域的查找规则，而这只是闭包的一部分。</p>
<p>分析一下上面的代码片段，函数<code>bar()</code>具有一个<strong>涵盖</strong>了<code>foo()</code>作用域的闭包（事实上不光是 foo，它涵盖了所能访问的所有作用域，比如全局作用域）。也可以认为<code>bar()</code><strong>封闭</strong>在了<code>foo()</code>的作用域中（很简单，因为<code>bar()</code>嵌套在<code>foo()</code>内部）。但是通过这种方式定义的闭包并不能直接<strong>进行观察</strong>。再来看下面的代码是如何清晰的展示闭包的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// 2  -- 这就是闭包的效果</span></span><br></pre></td></tr></table></figure>

<p>按照词法作用域查找规则，全剧作用域是看不到且访问不到<code>foo()</code>作用域中的变量 a 的，但是现在我们却打印出了<code>a</code>的值，这是怎么回事呢？</p>
<p>函数<code>bar()</code>的词法作用域能够访问<code>foo()</code>的内部作用域，然后我们将<code>bar()</code>函数本身当作一个值类型进行传递，我们将 bar 所引用的<strong>函数对象</strong>本身当作值返回。</p>
<p>在<code>foo()</code>执行后，其返回值（也就是内部的函数<code>bar</code>）赋值给变量<code>baz</code>并调用<code>baz()</code>,实际上只是通过不通的标识符引用调用了内部函数<code>bar()</code>。（表示符<code>bar</code>和<code>baz</code>指向的是同一个函数对象）</p>
<p><code>bar()</code>显然可以被正常执行，但是在这个例子中，它是在<strong>定义自己的词法作用域以外的地方</strong>被执行的（<code>bar</code>函数是在<code>foo</code>函数的内部被定义的，但是确是在全局作用域被调用执行的）。</p>
<p>在<code>foo()</code>执行之后，通常会期待<code>foo()</code>的整个内部作用域都会被销毁，因为我们知道引擎有垃圾回收机制来释放不再使用的内存空间，由于看上去<code>foo()</code>内部的内容不会再被使用，因此很自然的考虑对其进行回收。而闭包的“神奇之处”就在于可以组织这件事情发生，事实上<code>foo()</code>内部作用域<strong>依然</strong>存在而没有被回收，那是谁还在使用这个内部作用域呢？或者说谁还在引用这个内部作用域中的变量呢？答案是<code>bar()</code>函数在使用，还记得<code>bar()</code>函数的内部仍然在访问<code>foo()</code>函数内部作用域中的变量<code>a</code>吗？</p>
<blockquote>
<p>💡 拜<code>bar()</code>函数声明的位置所赐，它拥有涵盖<strong>整个</strong><code>foo()</code>内部作用域的闭包，使得该作用域能够一直存活，以供<code>bar()</code>在之后任何时间进行引用。</p>
</blockquote>
<p><code>bar()</code>依然持有对<code>foo()</code>内部作用域的引用，而这个引用本身就叫做闭包。尽管这个函数在定义它的词法作用域以外的地方被调用，但闭包使得该函数可以继续访问定义它时的那个词法作用域。</p>
<p>无论你使用何种方式对函数类型的值<strong>进行传递</strong>，当函数在别处进行调用时都可以观察到闭包，来看以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">baz</span>(bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>(); <span class="comment">// 这个例子中的 fn 指向的就是 bar 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>把内部函数<code>bar</code>当作参数传递给<code>baz</code>函数，<code>baz</code>函数内部直接调用这个函数（在<code>baz</code>内部叫做 fn），这个<code>fn()</code>函数携带着涵盖<code>foo()</code>内部作用域的闭包，因此可以访问到变量<code>a</code>。</p>
<p>传递函数也可以是间接的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  fn = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>(); <span class="comment">// 这也是闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>无论通过何种手段将内部函数<strong>传递</strong>到<strong>定义它时的那个词法作用域之外的地方</strong>，它都会<strong>持有</strong>对原始定义它的那个作用域的引用，无论在何处执行这个函数都会使用闭包。</p>
<h2 id="2-闭包无处不在"><a href="#2-闭包无处不在" class="headerlink" title="2. 闭包无处不在"></a>2. 闭包无处不在</h2><p>其实我们平时写过的代码中到处都是闭包的身影：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">wait</span>(<span class="string">&#x27;Hello, closure!&#x27;</span>); <span class="comment">// 1 秒后输出 &quot;Hello, closure!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这代码片段中，我们将一个内部函数<code>timer</code>作为参数传递给<code>setTimeout</code>函数，<code>time()</code>函数具有涵盖<code>wait()</code>函数内部词法作用域的闭包，因此还保有对变量<code>message</code>的引用。<code>wait()</code>函数执行 1000 毫秒以后，它的内部作用域并不会消失，timer 函数依然保有<code>wait()</code>作用域的闭包。</p>
<blockquote>
<p>💡 本质上<strong>无论何时何地</strong>，如果将函数（内部会访问它所在的词法作用域的变量）作为第一级的值类型并到处传递，我们就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或同步任务）中，只要使用了<strong>回调函数</strong>，实际上就是在使用闭包！</p>
</blockquote>
<p>对了，之前介绍的 IIFE 模式算是闭包吧？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>:</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>严格上来讲它并不算是闭包，为什么呢？因为函数 IIFE 并不是在定义它的词法作用域之外被执行的。它是在定义时所在的词法作用域中执行的，变量 a 是通过普通的词法作用域查找规则而非闭包被发现的。</p>
<p>尽管 IIFE 本身并不是观察闭包的恰当例子，但时它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。</p>
<h2 id="3-循环和闭包"><a href="#3-循环和闭包" class="headerlink" title="3. 循环和闭包"></a>3. 循环和闭包</h2><p>要说明闭包，循环是一个很好的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++&gt;) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况我们对这段代码的运行期望是分别输出数字 1、2、3、4、5，每秒一次，每次一个数字。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。这是为什么？</p>
<p>首先，6 是从哪里来的呢？这个循环的终止条件是 i 不再 &lt;&#x3D; 5，条件首次成立时 i 的值为 6，因此输出显示的结果是循环结束时 i 的最终值。</p>
<p>我们知道，传递给<code>setTimeout</code> 的回调函数会在指定的时间之后被放入循环队列等待执行,最起码也要等到主线程的同步代码执行完之后才能执行，因此这些函数一定是会<strong>在循环结束后</strong>才执行的。事实上，即使每个迭代传递给<code>setTimeout</code>的延迟时间是 0，所有的回调函数也依然会在循环结束后才会被执行。</p>
<p>那么代码中是什么“缺陷”导致了它的行为和语义所描述的不一致呢？</p>
<p>这段代码里我们试图”假设“循环中的每一次迭代<strong>在运行时</strong>都会给自己<strong>捕获</strong>一个 i 的副本。但是根据作用域的原理，实际情况是：尽管循环中的五个函数是在各个迭代中<strong>分别定义</strong>的，但是它们都被<strong>封闭</strong>在同一个共享的全局作用域中，而 i 也是在那个共享的作用域中定义的，因此<strong>这些函数访问的是同一个 i， 实际上也只有这一个 i。</strong> 循环让我们误以为背后有更复杂的机制在起作用，实际上并没有。</p>
<p>问题清楚了，那么如何解决呢？</p>
<p>其实我们需要的是闭包作用域，特别是在循环过程中的每一次迭代都需要一个闭包作用域。这样每次迭代中定义的函数 timer 都可以访问自己携带的闭包作用域中的互相独立的 i。</p>
<h3 id="3-1-解决方案一：IIFE"><a href="#3-1-解决方案一：IIFE" class="headerlink" title="3.1 解决方案一：IIFE"></a>3.1 解决方案一：IIFE</h3><p>那如何创建闭包作用域呢？还记得前面提到的 IIFE 吗？我们说 IIFE 是最常用来创建可以被封闭起来的闭包的工具。那么我们用 IIFE 来试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> j = i; <span class="comment">// 在每一次迭代中我们都在这个封闭作用域中定义一个属于自己的 j，它的值等于当前迭代的 i</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再来改进一下</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i); <span class="comment">// 直接把每次迭代的 i 作为参数传递给 IIFE，其实等价于 var j = i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在迭代内部使用 IIFE 会为<strong>每个迭代都生成一个全新的封闭作用域</strong>，使得延迟的回调函数 timer 可以将新的作用域封闭在每次迭代的内部。这样，每个迭代都可以访问自己的 j 变量，而不会影响到其他迭代的 j 变量。</p>
<h3 id="3-2-解决方案二：块作用域"><a href="#3-2-解决方案二：块作用域" class="headerlink" title="3.2 解决方案二：块作用域"></a>3.2 解决方案二：块作用域</h3><p>仔细思考前面 IIFE 的解决方案，我们使用 IIFE 在每次迭代时都创建了一个新的封闭作用域，换句话说，我们每次迭代都<strong>需要</strong>一个块作用域。那除了使用 IIFE 来直接创建一个封闭的作用域外，还有其他方法吗？当然！还记得前面介绍的 let 吗？ let 可以用来“劫持”块作用域。</p>
<p>使用 let 本质上是<strong>将一个块转换成一个可以被关闭的作用域。</strong>因此，下面的代码就可以正常运行了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = i; <span class="comment">// 这里使用 let 而不是 var 来定义 j</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">  &#125;, j * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码还可以进一步改进，我们知道，for 循环头部的 let 声明还会有一个特殊的行为，这个行为指出：变量在循环迭代过程中<strong>不止被声明一次，而是每次迭代都会被重新声明</strong>。随后的每一个迭代都会使用<strong>上一个迭代结束时的初始值</strong>来初始化这个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里直接使用 let 声明 i 变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-模块"><a href="#4-模块" class="headerlink" title="4. 模块"></a>4. 模块</h2><p>闭包的强大威力还体现在其他代码模式中，接下来我们来研究一下其中最强大的一个：模块。</p>
<p>先看下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&#x27;cool&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&#x27;!&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码里并没有明显的闭包，只有两个私有数据变量 something 和 another，以及两个内部函数 doSomething 和 doAnother。它们的词法作用域就是 foo 函数的内部作用域（而这个就是闭包）。</p>
<p>再看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&#x27;cool&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&#x27;!&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doAnother</span>: doAnother,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">CoolModule</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">doSomething</span>(); <span class="comment">// &quot;cool&quot;</span></span><br><span class="line">foo.<span class="title function_">doAnother</span>(); <span class="comment">// &quot;1!2!3&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个模式在 JavaScript 中被称为<strong>模块</strong>。</p>
<p>我们仔细来分析一下这段代码。</p>
<p>首先 CoolModule 只是一个普通的函数，必须要调用它来创建一个模块实力。<strong>如果不执行外部函数，内部作用域和闭包都无法被创建。</strong></p>
<p>其次，<code>CoolModule()</code>返回一个用对象字面量语法<code>&#123;key: value&#125;</code>来表示的对象，这个对象内部含有对内部函数的引用而<strong>不是</strong>内部私有数据变量的引用，这样我们就保证了内部数据变量时<strong>隐藏且私有</strong>的状态，我们可以将这个对象类型的返回值看作是<strong>模块暴露的公共 API</strong></p>
<p>然后这个对象类型的返回值被赋值给外部变量 foo，然后就可以通过它来访问 API 中的属性和方法了，比如<code>foo.doSomething()</code>和<code>foo.doAnother()</code>。<code>doSomething()</code>和<code>doAnother()</code>函数具有涵盖模块实例内部作用域的闭包（通过调用<code>CoolModule()</code>实现）。当通过返回一个含有属性引用的对象的方式来将内部函数传递到词法作用域外部时，我们就创建了可以观察和实践闭包的条件。</p>
<p>简单的总结一下，模块模式需要两个必要条件：</p>
<ol>
<li>必须有外部的封闭函数，该函数必须被至少调用一次（每一次调用都会创建一个新的模块实例）。</li>
<li>封闭函数必须至少返回一个<strong>内部函数</strong>，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<h3 id="4-1-单例模式"><a href="#4-1-单例模式" class="headerlink" title="4.1 单例模式"></a>4.1 单例模式</h3><p>刚才的例子中的<code>CoolModule()</code>可以称之为一个模块创建器，它可以被调用任意多次，每次调用都会创建一个新的模块实例。但是当我们只需要一个实例时（单例模式），可以对这个模式进行简单的改进：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&#x27;cool&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&#x27;!&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doAnother</span>: doAnother,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">foo.<span class="title function_">doSomething</span>(); <span class="comment">// &quot;cool&quot;</span></span><br><span class="line">foo.<span class="title function_">doAnother</span>(); <span class="comment">// &quot;1!2!3&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们将模块函数变成了 IIFE，<strong>立即调用</strong>这个函数并将返回值直接赋值给单例的模块标识符 foo。</p>
<p>模块也是普通的函数，也可以接受参数，比如下边的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">identify</span>: identify,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="title class_">CoolModule</span>(<span class="string">&#x27;foo1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="title class_">CoolModule</span>(<span class="string">&#x27;foo2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">foo1.<span class="title function_">identify</span>(); <span class="comment">// &quot;foo1&quot;</span></span><br><span class="line">foo2.<span class="title function_">identify</span>(); <span class="comment">// &quot;foo2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-动态命名模块公共-API"><a href="#4-2-动态命名模块公共-API" class="headerlink" title="4.2 动态命名模块公共 API"></a>4.2 动态命名模块公共 API</h3><p>模块模式的另一个简单而又强大的用法是命名将要作为公共 API 返回的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    publicAPI.<span class="property">identify</span> = identify2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">identify1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;identify1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">identify2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;identify2&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">    <span class="attr">change</span>: change,</span><br><span class="line">    <span class="attr">identify</span>: identify1,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="string">&#x27;foo module&#x27;</span>);</span><br><span class="line">foo.<span class="title function_">identify</span>(); <span class="comment">// &quot;identify1&quot;</span></span><br><span class="line">foo.<span class="title function_">change</span>();</span><br><span class="line">foo.<span class="title function_">identify</span>(); <span class="comment">// &quot;identify2&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码片段通过在模块实例内部保留对公共 API 对象的内部引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加或者删除方法和属性，以及修改它们的值。</p>
<h3 id="4-3-现代的模块机制"><a href="#4-3-现代的模块机制" class="headerlink" title="4.3 现代的模块机制"></a>4.3 现代的模块机制</h3><p>大多数模块依赖加载器&#x2F;管理器本质上都是将这种模块定义封装在一个友好的 API。先来看一下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyModules</span> = (<span class="keyword">function</span> (<span class="params">modules</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">define</span>(<span class="params">name, deps, implementation</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      deps[i] = modules[deps[i]]; <span class="comment">// 这一步是将依赖数组中的模块标识符（字符串）变为实际对应的模块实例引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    modules[name] = implementation.<span class="title function_">apply</span>(implementation, deps);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> modules[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">define</span>: define,</span><br><span class="line">    <span class="attr">get</span>: get,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这段代码的核心是<code>modules[name] = implementation.apply(implementation, deps)</code>为模块的定义引入了包装函数（可以传入任何依赖），并且将返回值也就是模块的公共 API，存储在一个根据名字来管理的模块列表对象中。</p>
<p>这样，我们就可以像下面这样定义模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyModules</span>.<span class="title function_">define</span>(<span class="string">&#x27;bar&#x27;</span>, [], <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">who</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`let me introduce: <span class="subst">$&#123;who&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyModules</span>.<span class="title function_">define</span>(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;bar&#x27;</span>], <span class="keyword">function</span> (<span class="params">bar</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> hungry = <span class="string">&#x27;hippo&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">awesome</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">hello</span>(hungry).<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">awesome</span>: awesome,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>define()</code>函数的第三个参数是一个函数，这个函数就是模块定义函数，正如前面所说的那样，调用这个函数将会返回一个模块实例对象。我们实现的这个模块管理器甚至允许模块定义函数接受其他模块的实例作为参数，这样在模块定义函数的内部就可以用其他模块实例的 API 了。</p>
<h3 id="4-4-ES6-中的模块机制"><a href="#4-4-ES6-中的模块机制" class="headerlink" title="4.4 ES6 中的模块机制"></a>4.4 ES6 中的模块机制</h3><p>ES6 中为模块增加了一级语法支持，在通过模块系统进行加载时，<strong>ES6 会将文件当作独立的模块来处理</strong>。ES6 的模块没有“行内”格式，必须被定义在一个独立的文件中（一个文件一个模块）。浏览器或者引擎有一个默认的“模块加载器”，可以在倒入模块的同时<strong>同步</strong>地加载模块文件。</p>
<p>基于函数的模块（例如我们前面提到的那些例子）并不是一个能被<strong>静态识别</strong>的模式（编译器无法识别），它们的 API 语义只有在运行时才会被考虑进来，因此我们可以在运行时修改一个模块暴露出来的 API。相比之下， <strong>ES6 中的模块 API 是静态的</strong>（API 不会在运行时改变）。由于编辑器知道这一点，因此可以在编译器检查期间对导入模块的 API 成员引用是否存在进行检查，如果并不存在，编译器会在编译时就抛出“早期”错误，而不会等到运行时再动态解析并报错。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>闭包看起来神秘且难以理解，但实际上它只是一个非常普通且明显的事实：那就是我们在词法作用域的环境下写代码，而函数也是值，可以被随意的传递来传递去。</p>
<p><strong>当函数可以记住并且访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时便产生了闭包</strong>。</p>
<p>闭包是一个非常强大的工具，可以利用它来实现模块等模式，模块主要有两个特征：</p>
<ol>
<li>为了创建一个内部作用域而调用了一个包装函数；</li>
<li>包装函数的返回值必须至少包含一个对内部函数的引用，这样就会创建一个<strong>涵盖整个包装函数内部作用域的闭包</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习 JavaScript 系列（二)：This 关键字</title>
    <url>/2024/04/26/advance-javascript/series-03-this/</url>
    <content><![CDATA[<h2 id="1-关于-this"><a href="#1-关于-this" class="headerlink" title="1. 关于 this"></a>1. 关于 this</h2><p>This 关键字是 JavaScript 中最复杂的机制之一，它是一个很特别的关键字，被<strong>自动</strong>定义在所有<strong>函数</strong>的作用域中。但是即使是非常有经验的 JavaScript 开发者也很难说清楚它到底指向什么。在缺乏对 This 清晰认知的情况下，它对我们来说无异于一种魔法。</p>
<h3 id="1-1-为什么要用-this-呢？"><a href="#1-1-为什么要用-this-呢？" class="headerlink" title="1.1 为什么要用 this 呢？"></a>1.1 为什么要用 this 呢？</h3><p>在解释为什么要用 this 之前我们先来看一个代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&quot;Hello, I&#x27;m&quot;</span> + identify.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Eric&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.<span class="title function_">call</span>(me); <span class="comment">// &quot;ERIC&quot;</span></span><br><span class="line">identify.<span class="title function_">call</span>(you); <span class="comment">// &quot;JOHN&quot;</span></span><br><span class="line"></span><br><span class="line">speak.<span class="title function_">call</span>(me); <span class="comment">// &quot;Hello, I&#x27;m ERIC&quot;</span></span><br><span class="line">speak.<span class="title function_">call</span>(you); <span class="comment">// &quot;Hello, I&#x27;m JOHN&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码可以在<strong>不同的上下文对象</strong>（me 和 you）中<strong>重复</strong>使用函数<code>identify()</code>和<code>speak()</code>而不用针对每一个对象编写不同版本的函数。</p>
<p>如果不使用 this， 那就需要给<code>identify()</code>和<code>speak()</code>函数显示的传入一个上下文对象，像这样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identify</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> context.<span class="property">name</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&quot;Hello, I&#x27;m&quot;</span> + <span class="title function_">identify</span>(context);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identify</span>(you); <span class="comment">// &quot;JOHN&quot;</span></span><br><span class="line"><span class="title function_">speak</span>(me); <span class="comment">// &quot;Hello, I&#x27;m ERIC&quot;</span></span><br></pre></td></tr></table></figure>

<p>随着你的使用模式越来越复杂，显示的传递上下文对象会让代码变得越来越混乱。然而，this 提供了一种更优雅的方式来<strong>隐式的“传递”一个对象引用</strong>，因此可以将 API 设计的更加简洁并且易于复用，请记住：<strong>函数可以自动的引用合适的上下文对象是非常重要的。</strong></p>
<h3 id="1-2-对-this-的误解"><a href="#1-2-对-this-的误解" class="headerlink" title="1.2 对 this 的误解"></a>1.2 对 this 的误解</h3><p>在解释 this 是如何工作之前我们先来消除一些关于 this 的错误认知。</p>
<h4 id="1-2-1-误解一：this-指向自身"><a href="#1-2-1-误解一：this-指向自身" class="headerlink" title="1.2.1 误解一：this 指向自身"></a>1.2.1 误解一：this 指向自身</h4><p>顾名思义，我们很容易错误的把 this 理解为指向自身，为什么需要从函数内部引用函数自身呢？常见的场景时递归（从函数内部调用这个函数）。JavaScript 开发者通常会认为，既然把函数看作一个对象（JavaScript 中所有的函数都是对象），那么就可以在调用函数时存储<strong>状态</strong>，这当然是可行的，但是除了函数对象还有许多更适合存储状态的地方。不过我们先来分析一下这个模式，看看 this 是否如我们所想的那样指向函数本身。思考一下下面这个代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> + num);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 6</span></span><br><span class="line"><span class="comment">// foo 7</span></span><br><span class="line"><span class="comment">// foo 8</span></span><br><span class="line"><span class="comment">// foo 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>根据输出我们知道 foo 被调用了 4 次，但是 <code>foo.count</code>仍然是 0，显然从字面理解 this 是错误的。执行 <code>foo.count = 0</code> 时，的确向函数对象 foo 添加了一个属性，但是函数内部代码<code>this.count</code>中的 this 并不是指向 foo 这个函数对象，虽然熟悉名相同，但是对象却不同。</p>
<p>如果要从函数内部引用它自身，只使用 this 是不够的，一般你需要通过一个<strong>指向函数对象的词法标识符</strong>来引用它。思考一下下面这两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  foo.<span class="property">count</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这是一个匿名函数，函数无法指向自身</span></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>注意第二个函数中我们传给 setTimeout 的回调函数没有函数名称标识符（匿名函数），因此函数无法从内部引用自身。</p>
<blockquote>
<p>💡 有一种传统的但是现在已经被弃用和批判的方法是使用 arguments.callee 来引用当前正在运行的函数对象，这是唯一一种可以从匿名函数内部引用自身的方法了，但是更好的方法是避免使用匿名函数，至少在需要自身引用时使用具名函数。arguments.callee 已经被废弃了，不应该再使用它。</p>
</blockquote>
<p>所以对于我们的例子来说，另一种解决方法是使用 foo 标识符来代替 this 来引用函数自身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> + num);</span><br><span class="line">  <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">  foo.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 6</span></span><br><span class="line"><span class="comment">// foo 7</span></span><br><span class="line"><span class="comment">// foo 8</span></span><br><span class="line"><span class="comment">// foo 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>然而这种方式回避了 this 的问题，完全依赖于变量 foo 的词法作用域。</p>
<p>另外一种方法是强制 this 指向 foo 函数对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span> + num);</span><br><span class="line">  <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    foo.<span class="title function_">call</span>(foo, i); <span class="comment">// 这里强制 this 指向 foo 函数对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 6</span></span><br><span class="line"><span class="comment">// foo 7</span></span><br><span class="line"><span class="comment">// foo 8</span></span><br><span class="line"><span class="comment">// foo 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">count</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-误解二：this-的作用域"><a href="#1-2-2-误解二：this-的作用域" class="headerlink" title="1.2.2 误解二：this 的作用域"></a>1.2.2 误解二：this 的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域，这种说法在某种情况下是正确的，但是在其他情况下却是错误的。</p>
<p>需要明确的是，<strong>this 在任何情况下都不指向函数的词法作用域</strong>。在 JavaScript 内部，作用域确实和对象很类似，可见的标识符都是它的属性，但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。</p>
<p>思考一下下面的这个例子，它试图跨越边界，使用 this 来隐式引用函数的词法作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>这个例子出自一个公共社区互助论坛中的精华代码，它清楚的展示了 this 多么容易误导人。首先，这段代码试图通过 <code>this.bar()</code>来引用 bar 函数，例子中能调用成功纯属意外，调用 bar 最自然的方式是省略前面的 this，直接使用词法作用域的查找机制来引用 bar 函数。此外，这段代码还试图使用 this 联通 foo 和 bar 的词法作用域，从而让 bar 函数内部能访问到 foo 函数内部的局部变量 a。这当然是不可能实现的，使用 this 不可能在词法作用域中查找到什么的。</p>
<h3 id="1-3-this-到底是什么？"><a href="#1-3-this-到底是什么？" class="headerlink" title="1.3 this 到底是什么？"></a>1.3 this 到底是什么？</h3><p>排除了一些误解后，我们来看看 this 到底是一种什么样的机制？</p>
<p>this 是在<strong>运行时</strong>绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong></p>
<p>当一个函数被调用时，会创建一个<strong>活动记录</strong>（有时候也被称为<strong>执行上下文</strong>）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个活动记录中的一个属性，会在函数执行的过程中用到。</p>
<h2 id="2-this-全面解析"><a href="#2-this-全面解析" class="headerlink" title="2. this 全面解析"></a>2. this 全面解析</h2><p>我们刚刚排出了一些对 this 的误解，并且明白了每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。接下来我们来探究一下如何寻找到函数的调用位置，从而判断函数在执行过程中会如何绑定 this。</p>
<h3 id="2-1-调用位置"><a href="#2-1-调用位置" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h3><p>所谓调用位置就是函数在代码中被<strong>调用</strong>的位置而不是被<strong>声明</strong>的位置，想要准确的找到函数被调用的位置，最重要的是分析<strong>调用站</strong>（就是为了到达当前执行位置所调用的所有函数），我们关心的调用位置就是在当前正在执行的函数中的<strong>前一个调用</strong>中。举个例子来说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是 全局作用域 -&gt; baz，因此当前的调用位置是调用 baz 的地方，也就是全局作用域</span></span><br><span class="line">  <span class="title function_">consoleloc</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//当前的调用栈是 全局作用域 -&gt; baz -&gt; bar，因此当前的调用位置是调用 bar 的地方，也就是 baz 函数内部</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前的调用栈是 全局作用域 -&gt; baz -&gt; bar -&gt; foo，因此当前的调用位置是调用 foo 的地方，也就是 bar 函数内部</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// baz 的调用位置， 这里是全局作用域</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-绑定规则"><a href="#2-2-绑定规则" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h3><p>调用位置确定后，我们就可以确定 this 的绑定规则了，判断需要应用下面<strong>四条</strong>规则中的哪一条：</p>
<h4 id="2-2-1-默认绑定"><a href="#2-2-1-默认绑定" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 默认绑定</h4><p>第一条就是最常用的函数调用类型：<strong>独立函数调用</strong>。可以把这条规则看作是无法应用其他规则时的默认规则。</p>
<p>思考下面这个代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>应该注意到的第一件事是：<strong>声明在全局作用域中的变量（比如 <code>var a = 2</code>）就是全局对象的一个同名属性。</strong> 它们本质上就是一个东西，并不是通过复制得到的。我们看到当调用<code>foo()</code>时，<code>this.a</code>被解析成了全局变量 a，这是因为在这个例子中应用了 this 的默认绑定，this 指向全局对象。</p>
<p>如何确定这里时应用了默认绑定呢？很简单，我们分析一下调用位置来看看 foo 是如何被调用的。在这个例子中，foo 是直接使用<strong>不带任何修饰的函数引用</strong>进行调用的，所以只能应用默认绑定，无法应用其他规则。</p>
<p>如果使用严格模式（strict mode），则不能将全局对象用作默认绑定，此时 this 会被绑定到 undefined。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-隐式绑定"><a href="#2-2-2-隐式绑定" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 隐式绑定</h4><p>第二条需要考虑的规则是<strong>调用位置是否有上下文对象</strong>，或者说是否被某个对象拥有或者包含，思考一下下面这个代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>注意 foo 函数的<strong>声明方式</strong>，以及之后是如何被当作引用属性添加到 obj 中的。无论是直接在 obj 中定义还是先定义再添加为 obj 的属性，<strong>这个函数严格来说都不属于 obj 对象</strong>。</p>
<p>然而调用位置会使用 obj 上下文来引用函数，因此你可以认为<strong>函数被调用时 obj 对象“拥有”或者“包含”函数引用</strong>。</p>
<p>无论你如何称呼这个模式，当 foo 被调用时，它的前面确实加上了对 obj 的引用。<strong>当函数引用有上下文对象时，隐式绑定规则会把函数调用时的 this 绑定到这个上下文对象</strong>。此时<code>this.a</code>和<code>obj.a</code>是一样的。</p>
<p>另外需要注意对象属性引用链中只有上一层或者最后一层在调用位置中起作用，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">obj2</span>: obj2,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj1.<span class="property">obj2</span>.<span class="title function_">foo</span>(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>一个最常见的 this 绑定问题就是被<strong>隐式绑定</strong>的函数会丢失绑定对象，也就是说它会应用<strong>默认绑定</strong>，从而把 this 绑定到全局对象或者 undefined 上（取决于是否是严格模式）。思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>; <span class="comment">// 函数别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是<strong>foo 函数本身</strong>，因此此时的<code>bar()</code>其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>另外一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的 fn 引用是 foo 函数本身</span></span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>参数传递就是一种<strong>隐式赋值</strong>，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。那如果我们把函数传入语言内置的函数（比如 setTimeout）而不是自己定义的函数呢？结果是一样的，没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;oops, global&#x27;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>, <span class="number">1000</span>); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中的 setTimeout 函数的实现和下面这段伪代码类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeout</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">// 等待 delay 毫秒</span></span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>回调函数丢失 this 绑定是非常常见的</strong>。除此之外，<strong>调用回调函数的函数可能会修改 this</strong>。无论哪种情况，this 的改变都是意想不到的，实际上你根本就无法控制回调函数的执行方式，因此也就无法控制调用位置得到期望的绑定。</p>
<h4 id="2-2-3-显式绑定"><a href="#2-2-3-显式绑定" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 显式绑定</h4><p>在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</p>
<p>如果我们不想在对象内部包含一个函数的引用，但是又想<strong>在某个对象上强制调用某个函数</strong>该怎么办呢？</p>
<p>答案就是使用函数的 call 和 apply 方法，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call 和 apply 方法。</p>
<p>这两个方法的第一个参数是一个<strong>对象</strong>，这个对象是给 this 准备的，接着在调用的时候将其绑定到 this，因为我们可以直接指定 this 的绑定对象，因此称之为<strong>显示绑定</strong>。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">// 2, 通过foo.call(obj),我们强制把它的this绑定到了obj上</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 使用 call 和 apply 方法时，如果第一个参数你传入了一个原始值（字符串、布尔或者数字类型），来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String()、 new Boolean()或者 new Number()），这被称为“装箱”（boxing）。</p>
</blockquote>
<p>遗憾的是，显示绑定并不能解决我们之前遇到的丢失绑定的问题。但是显示绑定的一个变种（<strong>硬绑定</strong>）可以解决这个问题，思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  foo.<span class="title function_">call</span>(obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(bar, <span class="number">1000</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬绑定的bar函数不可能再修改它的this</span></span><br><span class="line">bar.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>我们创建了函数 bar， 并在它的内部手动调用了&#96;foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj 上。无论之后如何调用 bar，它总会手动在 obj 上调用 foo。这种绑定是一种<strong>强制绑定</strong>，称之为<strong>硬绑定</strong>。</p>
<p>硬绑定的一个典型的应用场景就是创建一个<strong>包裹函数</strong>，负责接收参数并返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// arguments 是调用bar时实际接受到的参数，是一个类数组对象</span></span><br><span class="line">  <span class="keyword">return</span> foo.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是创建一个可重复使用的辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">fn, thisContext</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(thisContext, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">bind</span>(foo, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>硬绑定是一种非常有用的模式，ES5 提供了内置的方法 <code>Function.prototype.bind</code>，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj); <span class="comment">// 返回一个新的函数，这个函数被硬绑定到了obj上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>bind 会返回一个<strong>硬编码</strong>的新函数，它会把指定的参数设置为 this 的上下文并调用原始函数。</p>
<p>JavaScript 语言和宿主环境的许多新的内置函数，以及第三方库的许多函数，都提供了一个可选的参数，通常被称为“上下文”（context），这个参数可以用来显式指定函数的 this 绑定对象。它和 bind 的作用一样，确保你的函数使用指定的 this。 举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(el, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;awesome&#x27;</span>,</span><br><span class="line">&#125;[</span><br><span class="line">  <span class="comment">// 调用 foo 函数，并显式指定 this 的绑定对象为 obj</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">].<span class="title function_">forEach</span>(foo, obj); <span class="comment">// 1 awesome, 2 awesome, 3 awesome</span></span><br></pre></td></tr></table></figure>

<p>这些函数实际上就是通过 call 或 apply 实现了显示绑定。</p>
<h4 id="2-2-4-new-绑定"><a href="#2-2-4-new-绑定" class="headerlink" title="2.2.4 new 绑定"></a>2.2.4 new 绑定</h4><p>这是最后一条 this 的绑定规则，不过在详细介绍之前我们需要先澄清一个非常常见的关于 JavaScript 中函数和对象的误解。</p>
<p>在传统的面相类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会自动调用类中的构造函数，通常的的使用形式是这样的：<code>something = new myClass(args)</code>; JavaScript 也有一个 new 操作符，使用起来也和那些语言差不多，因此绝大多数开发着都认为 JavaScript 也和那些语言的 new 的机制是一样的。然而，<strong>JavaScript 中 new 的机制和面向类的语言完全不同</strong>。</p>
<p>在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。<strong>它们并不会属于某个类，也不会实例化一个类</strong>。实际上，它们甚至都不能说是一种特殊的函数类型，它们和普通的函数没有任何区别，只是被 new 操作符调用的<strong>普通函数</strong>而已。</p>
<p>ES5 这样描述 Number() 作为构造函数时的行为：</p>
<blockquote>
<p>Number 构造函数：当 Number 在 new 表达式中被调用时，它是一个构造函数，它会初始化新建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数（比如 Number()）在内的所有函数都可以用 new 来调用，这种函数调用被称为<strong>构造函数调用</strong>。这里有一个重要但是非常细微的区别：<strong>实际上并不存在所谓的“构造函数”，只有对函数的“构造调用”</strong>。</p>
<p>使用 new 来调用函数，或者发生函数的构造调用时，会自动执行下面的操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个对象会被执行[[Prototype]]链接，因此会继承构造函数的原型。</li>
<li>这个对象会绑定到函数调用的 this 关键字。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title function_">foo</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>使用 new 来调用 foo 时，我们会构造一个新的对象并把它绑定到 foo 调用中的 this 上。<strong>new 是最后一种可以影响函数调用时 this 绑定行为的方法， 我们称之为 new 绑定</strong>。</p>
<h3 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h3><p>在函数调用中决定 this 绑定的四条规则中，如果某个位置可以应用多条规则该怎么办？换句话说，这四条规则的优先级是什么？</p>
<p>毫无疑问，<strong>默认绑定的优先级是四条规则中最低的</strong>，所以可以先不考虑它。隐式绑定和显示绑定哪个优先级更高呢？我们不妨来测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>(obj1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>显示绑定的优先级更高</strong>，因此在判断时应该先考虑是否存在显示绑定。</p>
<p>接下来需要弄清楚 new 绑定和隐式绑定的优先级高低：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(<span class="number">2</span>); <span class="comment">// 隐式绑定，this 绑定到 obj1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2, <span class="number">3</span>); <span class="comment">// 显示绑定，this 绑定到 obj2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>(<span class="number">4</span>); <span class="comment">// new 绑定，this 绑定到新创建的对象而不是 obj1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <strong>new 绑定比隐式绑定优先级高</strong>。最后，new 绑定和显示绑定哪个优先级更高呢？</p>
<p>还记得硬绑定是如何工作的吗？<code>Function.prototype.bind()</code>会创建一个新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。这样看起来硬绑定（也是显示绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。我们来测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj1); <span class="comment">// 新返回的 bar 函数将 this 硬绑定到了 obj1</span></span><br><span class="line"><span class="title function_">bar</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// 将硬绑定了 obj1 的新的函数 bar 作为构造函数调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">a</span>); <span class="comment">// 3 可以看到 this 指向了新新创建的对象 baz 上而不是 obj1</span></span><br></pre></td></tr></table></figure>

<p>出乎意料，尽管 bar 函数被硬绑定到了 obj1 上，但是 <code>new bar(3)</code> 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj）调用 bar 中的 this，因为使用了 new 绑定，我们得到了一个名为 baz 的新的对象，并且 baz.a 的值为 3。</p>
<p>来看一下 ES5 中内置的 Function.prototype.bind() 方法的一种实现（来自 MDN）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果调用 bind 方法的对象不是函数，则抛出一个 TypeError 异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">        <span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 获取调用 bind 方法时传入的参数, 注意这里是从 index 1 开始，因为第一个参数是要绑定到 this 的对象</span></span><br><span class="line">    <span class="keyword">var</span> fToBind = <span class="variable language_">this</span>; <span class="comment">// 将调用 bind 方法的函数保存下来</span></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 空函数, 作为返回的函数的原型</span></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 包裹函数</span></span><br><span class="line">      <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(</span><br><span class="line">        <span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="variable language_">this</span> : oThis,</span><br><span class="line">        aArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 为 fNOP 设置原型</span></span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>(); <span class="comment">// 为 fBound 设置原型，并将其原型设置为 fNOP 的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound; <span class="comment">// 返回包裹函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现的核心部分是这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="variable language_">this</span> : oThis;</span><br><span class="line"><span class="comment">// 以及这部分：</span></span><br><span class="line">fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br><span class="line">fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br></pre></td></tr></table></figure>

<p>这部分代码是模拟 bind 方法实现中最关键的一部分，处理了<strong>绑定函数的调用方式</strong>和<strong>构造函数行为</strong>的兼容性问题。我们来逐步分析：</p>
<p>首先是这句代码：<code>this instanceof fNOP &amp;&amp; oThis ? this : oThis</code>:</p>
<ul>
<li>bind 的目标是创建一个新的函数（fBound），并绑定一个指定的 this 值（oThis）以及一组参数（aArgs）。</li>
<li>新的函数（fBound）可以以两种方式调用：<ol>
<li>普通函数调用：绑定的 this 值应该是 oThis。</li>
<li>构造函数调用：如果用 new 调用 fBound，this 应该指向新创建的对象，而不是绑定时的 oThis。</li>
</ol>
</li>
<li><code>this instanceof fNOP</code>正是用来判断当前的调用方式是否是通过 new 调用的（即构造函数调用），fBound 的原型被设置为 fNOP 的实例（<code>fBound.prototype = new fNOP()</code>）。因此，如果当前的 this 是 fNOP 的实例，则说明 fBound 是通过 new 调用的。</li>
<li>如果 <code>this instanceof fNOP</code>为真，进一步检查是否存在 oThis。<code>&amp;&amp; oThis</code>是为了确保在普通函数调用时能正确绑定到指定的对象。</li>
</ul>
<p>完整的逻辑就是：如果 this 是 fNOP 的实例（即通过 new 调用），返回当前的 this，表示 fBound 被用作构造函数，this 应该是新创建的对象。如果不是构造函数调用，返回 oThis，表示普通的函数调用中，this 应该绑定到指定的对象 oThis。</p>
<p>最后<code>fNOP.prototype = this.prototype;</code>的作用是确保通过 bind 创建的函数（fBound）能够继承原始函数（fToBind）的原型链，从而保持一致的原型行为。</p>
<p>简单的说： <strong>如果硬绑定函数是通过 new 调用的，则会忽略硬绑定的 this，而是将 this 绑定到新创建的对象上</strong>。</p>
<p>那为啥非得在 new 中使用硬绑定的函数呢？直接使用普通函数不行吗？其实主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化的时候就可以只传其余参数。bind 函数的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其余参数都传递给下层的函数（这种技术被称为“部分应用”，是“柯里化”的一种）。举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之所以使用 null 是因为在本例子中我们不关心硬绑定的 this 是什么，反正使用 new 时都会忽略它</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="string">&#x27;p2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">val</span>); <span class="comment">// &#x27;p1p2&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-判断-this"><a href="#2-4-判断-this" class="headerlink" title="2.4 判断 this"></a>2.4 判断 this</h3><p>现在我们基本上可以根据优先级来判断函数在某个调用位置应用的是哪条规则了，可以按照下面的顺序来进行判断：</p>
<ol>
<li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 <code>var bar = new foo();</code></li>
<li>函数是否通过 call、apply（显示绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。 <code>var bar = foo.call(obj2);</code></li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 <code>obj1.foo();</code></li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。<code>var bar = foo();</code></li>
</ol>
<p>这几条基本上涵盖了所有函数正常调用时 this 的绑定原理了。然而，凡事总有例外。</p>
<h3 id="2-5-绑定例外"><a href="#2-5-绑定例外" class="headerlink" title="2.5 绑定例外"></a>2.5 绑定例外</h3><p>在某些情况下 this 的绑定行为会出乎意料之外，你认为应当应用其他规则时，实际上应用的可能是默认绑定规则。</p>
<h4 id="2-5-1-被忽略的-this"><a href="#2-5-1-被忽略的-this" class="headerlink" title="2.5.1 被忽略的 this"></a>2.5.1 被忽略的 this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>什么情况下会传入 null 呢？一种非常常见的做法是使用 apply 来“展开”一个数组，并当作参数传入一个函数。类似的使用 bind 也可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a:&#x27;</span> + a + <span class="string">&#x27;, b:&#x27;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把数组“展开“成参数</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>

<p>在这两个例子中，函数都不关心 this，但是你仍旧需要传入一个占位值，这时 null 可能是一个不错的选择。不过总是使用 null 来忽略 this 绑定可能产生一些副作用。<strong>如果某个函数确实使用了 this（比如第三方库的某个函数）），那默认绑定规则会把 this 绑定到全局对象，这可能会导致不可预计的后果。</strong></p>
<blockquote>
<p>💡 关于展开一个数组，ES6 提供了 … 操作符可以代替 apply 来“展开”数组，foo(…[1,2]) 和 foo.apply(null, [1,2]) 效果相同，这样可以避免不必要的 this 绑定。</p>
</blockquote>
<p>一种“更安全”的做法是传入一个“特殊的对象“，把 this 绑定到这个对象上不会对你的程序产生任何副作用，这个对象就是<strong>空的非委托对象</strong>。在 JavaScript 中，创建一个空对象最简单的方法就是使用<code>Object.create(null)</code>，它和 <code>&#123;&#125;</code>很像，但是并不会创建<code>Object.prototype</code>这个委托，所以它比<code>&#123;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a:&#x27;</span> + a + <span class="string">&#x27;, b:&#x27;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空的非委托对象</span></span><br><span class="line"><span class="keyword">var</span> Ø = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组展开成参数</span></span><br><span class="line">foo.<span class="title function_">apply</span>(Ø, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(Ø, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>使用 Ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，Ø 表示“我希望 this 是空”，这比 null 的含义更清楚。</p>
<h4 id="2-5-2-间接调用"><a href="#2-5-2-间接调用" class="headerlink" title="2.5.2 间接调用"></a>2.5.2 间接调用</h4><p>另一个需要注意的是我们可能（有意或者无意）创建一个函数的“间接引用”，在这种情况下，调用这个函数会使用默认绑定规则。<strong>间接引用</strong>最容易在赋值时发生：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line">o.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line">(p.<span class="property">foo</span> = o.<span class="property">foo</span>)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>赋值表达式<code>(p.foo = o.foo)</code>的返回值是目标函数的引用</strong>，因此调用位置是<code>foo()</code>而不是<code>p.foo()</code>或者<code>o.foo()</code>。在这种情况下，应用的是默认绑定规则。</p>
<h4 id="2-5-3-软绑定"><a href="#2-5-3-软绑定" class="headerlink" title="2.5.3 软绑定"></a>2.5.3 软绑定</h4><p>之前我们提到了硬绑定，这种绑定方式可以把 this 绑定到指定的对象（除了使用 new 进行调用时），当时有时候硬绑定会大大降低函数的灵活性，<strong>使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this 了。</strong>如果可以给默认绑定指定一个除了全局对象和 undefine 以外的值，就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改 this 的能力。比如一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> curried = [].<span class="property">silce</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 保存剩余参数</span></span><br><span class="line">    <span class="keyword">var</span> bound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">        !<span class="variable language_">this</span> || <span class="variable language_">this</span> === (<span class="variable language_">window</span> || <span class="variable language_">global</span>) ? obj : <span class="variable language_">this</span>,</span><br><span class="line">        curried.<span class="property">concat</span>.<span class="title function_">apply</span>(curried, <span class="variable language_">arguments</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">    bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是这句代码：<code>!this || this === (window || global) ? obj : this</code>,它将决定 <code>fn.apply</code> 方法的 this 值：如果 this 绑定到了全局对象或者 undefined， 那就把 this 绑定到指定的对象 obj 上，否则就保持原来的 this。接下来看看如何使用这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name:&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.<span class="title function_">softBind</span>(obj1); <span class="comment">// fooOBJ 就是上边代码片段中返回的 bound 函数</span></span><br><span class="line"><span class="title function_">fooOBJ</span>(); <span class="comment">// name:obj1，这里的效果和硬绑定一样</span></span><br><span class="line"></span><br><span class="line">obj2.<span class="property">foo</span> = foo.<span class="title function_">softBind</span>(obj1);</span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// name:obj2, 注意这里不一样了，这里是在obj2的上下文中调用foo的（属于隐式绑定），如果是硬绑定的话隐式绑定是无法修改 this 的，this还会是obj1， 然而这里是软绑定，this会被绑定到obj2</span></span><br><span class="line"></span><br><span class="line">fooOBJ.<span class="title function_">call</span>(obj3); <span class="comment">// name:obj3, 这里我们用显示绑定的方式调用 fooOBJ，this 被绑定到了 obj3 上，还是和硬绑定不一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.<span class="property">foo</span>, <span class="number">100</span>); <span class="comment">// name:obj1, 这里obj2.foo是引擎直接在全局调用的，按照默认绑定规则，this 应该绑定到了全局对象，然而软绑定仍旧会把 this 绑定到 obj1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-this-的词法"><a href="#2-6-this-的词法" class="headerlink" title="2.6 this 的词法"></a>2.6 this 的词法</h3><p>前面的四条规则已经可以涵盖所有正常的函数，但是 ES6 引入了一种无法使用这些规则的特殊类型的函数：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符<code>=&gt;</code>定义的。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局作用域）来决定 this。</strong></p>
<p>来看一下箭头函数的词法作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this 继承自 foo</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">call</span>(obj1);</span><br><span class="line">bar.<span class="title function_">call</span>(obj2); <span class="comment">// 2 注意这里的 this 并不是 obj2，而是 obj1</span></span><br></pre></td></tr></table></figure>

<p>foo 内部创建的箭头函数会“捕获”调用时 foo 的 this。由于 foo 的 this 绑定到 obj1，因此 bar（引用的是箭头函数）的 this 也会绑定到 obj1，<strong>箭头函数的绑定无法被修改（new 也不行）。</strong></p>
<p>箭头函数最常用于回调函数中，如事件处理器或者定时器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 this 在词法上继承自 foo</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>箭头函数可以像 bind 一样确保函数的 this 被绑定到指定的对象，此外其重要性还体现在<strong>它用更常见的词法作用域取代了传统 this 机制。</strong>实际上在 ES6 之前我们就已经在使用一种几乎和箭头函数一模一样的模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">a</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>self = this</code>和箭头函数看起来都可以取代 bind，但是从本质上来说，它们想替换的是 this 机制。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title>在你使用 memo() | useMemo()之前...</title>
    <url>/2021/12/22/before-use-memo/index/</url>
    <content><![CDATA[<p>关于 React 性能优化的文章有很多。通常，如果某些状态更新很慢，你需要做以下几件事：</p>
<ol>
<li>确认你正在运行的是生产版本。（开发版本故意较慢，在极端情况下甚至会慢一个数量级。）</li>
<li>确认你没有把状态提升到不必要的位置。（例如，把输入状态放在集中存储中可能不是最好的主意。）</li>
<li>运行 React DevTools Profiler 查看哪些组件重新渲染，并用 <code>memo()</code> 包裹最耗时的子树。（在需要的地方添加 <code>useMemo()</code>。）</li>
</ol>
<p>最后一步令人烦恼，特别是对于中间的组件，理想情况下编译器可以为你处理这些问题。未来可能会实现。</p>
<p><strong>在这篇文章中，我想分享两种不同的技术。</strong> 它们出乎意料的基础，因此人们很少意识到它们能提高渲染性能。</p>
<p><strong>这些技术是对你已经知道的技术的补充！</strong> 它们不能取代 <code>memo</code> 或 <code>useMemo</code>，但你可以先尝试一下。</p>
<h2 id="一个（人为的）慢组件"><a href="#一个（人为的）慢组件" class="headerlink" title="一个（人为的）慢组件"></a>一个（人为的）慢组件</h2><p>这里有一个严重渲染性能问题的组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setColor(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveTree</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ExpensiveTree</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> now = performance.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">while</span> (performance.<span class="title function_">now</span>() - now &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// Artificial delay -- do nothing for 100ms</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I am a very slow component tree.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的问题是，每当 <code>color</code> 在 <code>App</code> 内部发生变化时，我们都会重新渲染 <code>&lt;ExpensiveTree /&gt;</code> ，我们人为地将其延迟得非常慢。</p>
<p>当然我可以把 <code>memo()</code> 放在上面，然而也就到此为止了，有很多关于它的现有文章，所以我不会花时间在它上面，我想展示两种不同的解决方案。</p>
<h2 id="解决方案-1：下移状态"><a href="#解决方案-1：下移状态" class="headerlink" title="解决方案 1：下移状态"></a>解决方案 1：下移状态</h2><p>如果您仔细查看渲染代码，您会发现返回的树中只有一部分实际上关心当前的 <code>color</code> ：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setColor(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveTree</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，让我们将该部分提取到 <code>Form</code> 组件中，并将状态向下移动到其中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveTree</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Form</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setColor(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果 <code>color</code> 发生更改，则只有 <code>Form</code> 会重新渲染。问题解决了。</p>
<h2 id="解决方案-2：提升内容"><a href="#解决方案-2：提升内容" class="headerlink" title="解决方案 2：提升内容"></a>解决方案 2：提升内容</h2><p>如果状态块在昂贵的树<em>之上</em>的某个地方使用，则上述解决方案不起作用。例如，假设我们将 <code>color</code> 放在<em>父级</em> <code>&lt;div&gt;</code> 上：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setColor(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveTree</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看来我们不能只是将不使用 <code>color</code> 的部分“提取”到另一个组件中，因为这将包括父 <code>&lt;div&gt;</code> ，然后父组件将包括 <code>&lt;ExpensiveTree /&gt;</code> 。这次不能回避 <code>memo</code> 了吧？</p>
<p>真的不可以吗？</p>
<p>答案其实非常简单：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ColorPicker</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveTree</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ColorPicker</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ColorPicker</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setColor(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将 <code>App</code> 组件分成两部分。依赖于 <code>color</code> 的部分以及 <code>color</code> 状态变量本身已移至 <code>ColorPicker</code> 中。</p>
<p>不关心 <code>color</code> 的部分留在 <code>App</code> 组件中，并作为 JSX 内容传递给 <code>ColorPicker</code> ，也称为 <code>children</code></p>
<p>当 <code>color</code> 更改时， <code>ColorPicker</code> 重新渲染。但它仍然具有上次从 <code>App</code> 获得的相同 <code>children</code> 属性，因此 React 不会访问该子树。</p>
<p>因此， <code>&lt;ExpensiveTree /&gt;</code> 不会重新渲染。</p>
<h2 id="有什么意义"><a href="#有什么意义" class="headerlink" title="有什么意义?"></a>有什么意义?</h2><p>在应用 <code>memo</code> 或 <code>useMemo</code> 等优化之前，看看是否可以将变化的部分与不变的部分分开可能是有意义的。</p>
<p>这些方法的有趣之处在于<strong>它们本身与性能没有任何关系</strong>。使用 <code>children</code> 属性来拆分组件通常会使应用程序的数据流更易于跟踪，并减少通过树向下查找的属性数量。在这种情况下，提高性能只是锦上添花，而不是最终目标。</p>
<p>奇怪的是，这种模式还可以在未来释放更多性能优势。</p>
<p>例如，当服务器组件稳定并准备好采用时，我们的 <code>ColorPicker</code> 组件可以从服务器接收其 <code>children</code> 。整个 <code>&lt;ExpensiveTree /&gt;</code> 组件或其部分都可以在服务器上运行，甚至顶级 React 状态更新也会“跳过”客户端上的这些部分。</p>
<p>这是连 <code>memo</code> 都做不到的事情！但同样，这两种方法是互补的。不要忽视向下移动状态（并向上提升内容！）</p>
<p>这不是一个新的想法。这是 React 组合模型的自然结果。它很简单，但却被低估了，值得更多的关注。</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>memo</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>一次线上白屏事故排查引发的前端静态资源缓存的思考</title>
    <url>/2023/09/28/cache/cache/</url>
    <content><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>最近遇到了一个线上白屏的故障，客户反映网站白屏，没有 Loading 状态，也没有任何可以交互的 UI。尝试使用无痕模式可以正常打开网页。这个情况在客户的电脑上偶尔出现，复现概率并不高，奇怪的是我们自己的电脑尝试了很多次并没有出现这个问题。好在我们让客户再次遇到这个问题的时候打开控制台并保存了控制台的截图，发现其中有两个 js 脚本文件（invisible.js 和 rocket-loader.min.js）加载失败，并且有一个 rum 接口出现 404 错误。</p>
<p>于是我们赶到客户现场排查，但是经过一顿捣鼓后并没有什么新的发现。但是注意到浏览器控制台没有启用 <code>Disable Cache</code> 选项，于是我们尝试启用该选项，发现白屏问题消失了。访问恢复正常，上述的 404 报错不仅没有报错，连对资源本身的请求也消失了。于是我们尝试从那些 404 的请求身上入手，探究本次事故发生的原因及解决方案。</p>
<p>以下是理解本次事故原因所需要了解的基本前提：</p>
<h3 id="1-1-公司项目的系统架构："><a href="#1-1-公司项目的系统架构：" class="headerlink" title="1.1 公司项目的系统架构："></a>1.1 公司项目的系统架构：</h3><ul>
<li>服务器：使用亚马逊 AWS，部署在东京。其中部署了 nginx 作为 web server 以及负责请求匹配和流量转发。</li>
<li>CDN 服务:国内访问走的是 aliyun、国外访问走的是 cloudflare 的两套方案。经过层层转发后，最终都会到达东京的 AWS 服务器。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-framework.png"
                        alt="alt text"
                 ></p>
<p>使用<a class="link"   href="https://www.cloudflare.com/zh-cn/learning/cdn/what-is-a-cdn/" >CDN<i class="fas fa-external-link-alt"></i></a>服务的原因主要在于以下几点:</p>
<ul>
<li>缩短网站加载时间</li>
<li>减少带宽成本</li>
<li>增加内容可用性和减少冗余</li>
<li>提高网站的安全性</li>
</ul>
<p>除此之外，现在的云服务器还会提供一些附加功能，比如<strong>性能优化、网站监控和分析</strong>，并且部分功能会通过<strong>在网站的 html 中插入 js 脚本的方式实现</strong>。其中，cloudflare 会通过插入 beacon.min.js 实现网站监控和分析，并通过 <a class="link"   href="https://developers.cloudflare.com/analytics/web-analytics/" >rum<i class="fas fa-external-link-alt"></i></a> 接口上报数据；通过插入 rocket-loader.min.js 实现<a class="link"   href="https://developers.cloudflare.com/speed/optimization/content/rocket-loader/" >性能优化<i class="fas fa-external-link-alt"></i></a>。</p>
<h3 id="1-2-浏览器的缓存机制："><a href="#1-2-浏览器的缓存机制：" class="headerlink" title="1.2 浏览器的缓存机制："></a>1.2 浏览器的缓存机制：</h3><p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching" >浏览器缓存机制<i class="fas fa-external-link-alt"></i></a>分为两种：</p>
<h4 id="1-2-1-强缓存："><a href="#1-2-1-强缓存：" class="headerlink" title="1.2.1 强缓存："></a>1.2.1 强缓存：</h4><p>浏览器的强缓存机制是指在不向服务器发送请求的情况下，直接从浏览器的缓存中读取资源。这种机制能够显著提升页面加载速度，减少网络请求，降低服务器压力。强缓存主要依赖于 HTTP 头中的<code>Expires</code> 和<code>Cache-Control</code>来实现。</p>
<ol>
<li><code>Expires</code> 是 HTTP&#x2F;1.0 中定义的字段，用于指定资源的过期时间，即在该时间之前，浏览器可以直接使用缓存中的资源，而不需要再次向服务器发送请求。</li>
</ol>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 21 Oct 2024 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<p>上述示例表示资源在 2024 年 10 月 21 日 07:28:00 之前有效，浏览器在此之前会直接从缓存中获取资源。</p>
<ol start="2">
<li><code>Cache-Control</code> 是 HTTP&#x2F;1.1 中定义的字段，提供了比 Expires 更灵活和强大的缓存控制功能。常见的取值包括：</li>
</ol>
<ul>
<li><code>max-age=&lt;seconds&gt;</code>：指定资源在缓存中的有效时间（以秒为单位）。</li>
<li><code>no-cache</code>：强制每次请求直接发送到服务器进行验证（并不是真的不缓存）。</li>
<li><code>no-store</code>：不缓存任何内容，每次请求都从服务器获取。</li>
<li><code>public</code>：表示响应可以被任何缓存（如浏览器、CDN 等）缓存。</li>
<li><code>private</code>：表示响应只能被单个用户缓存，不能被共享缓存（如 CDN）缓存。</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=3600, public</span><br></pre></td></tr></table></figure>

<p>上述示例表示资源在缓存中最长有效时间为 3600 秒，可以被任何缓存缓存。</p>
<p><strong>强缓存机制的工作流程</strong></p>
<ol>
<li>初次请求：</li>
</ol>
<ul>
<li>浏览器向服务器请求资源。</li>
<li>服务器返回资源，同时返回 <code>Expires</code> 或 <code>Cache-Control</code> 头部信息。</li>
<li>浏览器将资源和相关的头部信息存储在缓存中。</li>
</ul>
<ol start="2">
<li>再次请求：</li>
</ol>
<ul>
<li>浏览器检查缓存中的资源是否仍然有效（依据 <code>Expires</code> 和<code>Cache-Control</code>）。</li>
<li>如果有效，直接从缓存中读取资源，不向服务器发送请求。</li>
<li>如果无效，发送请求到服务器，服务器返回新的资源和更新的缓存控制头部。</li>
</ul>
<p>示例:假设我们有一个静态资源 example.js，服务器返回的响应头如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=600</span><br></pre></td></tr></table></figure>

<p>这表示 example.js 在缓存中有效期为 600 秒（10 分钟）。在此期间，浏览器再次请求该资源时，会直接从缓存中读取，而不需要发送请求到服务器。</p>
<p><strong>强缓存的优缺点</strong></p>
<ol>
<li>优点：</li>
</ol>
<ul>
<li><strong>提升性能</strong>：减少网络请求，显著加快页面加载速度。</li>
<li><strong>减轻服务器压力</strong>：减少服务器的负载和带宽消耗。</li>
</ul>
<ol start="2">
<li>缺点：</li>
</ol>
<ul>
<li><strong>内容更新延迟</strong>：如果服务器上的资源更新了，但在缓存有效期内，用户仍会看到旧的资源。可以通过设置合理的缓存时间和使用版本号（如文件名中加入 hash 值）来解决此问题。</li>
</ul>
<h4 id="1-2-2-协商缓存："><a href="#1-2-2-协商缓存：" class="headerlink" title="1.2.2 协商缓存："></a>1.2.2 协商缓存：</h4><p>浏览器的协商缓存机制（又称为条件缓存机制）是一种<strong>在资源过期后</strong>，通过与服务器进行通信来确认资源是否更新的缓存机制。协商缓存机制可以有效减少不必要的资源传输，提高页面加载速度，同时确保用户获取最新的资源。</p>
<p>协商缓存主要通过以下两个 HTTP 头部来实现：<code>Last-Modified/If-Modified-Since</code> 和 <code>ETag/If-None-Match</code>。</p>
<ol>
<li><code>Last-Modified/If-Modified-Since</code>：</li>
</ol>
<ul>
<li><code>Last-Modified</code>：<strong>服务器在响应中</strong>包含的头部字段，表示资源的最后修改时间。</li>
<li><code>If-Modified-Since</code>：<strong>浏览器在请求中</strong>包含的头部字段，表示上次请求时获取的 Last-Modified 时间。</li>
</ul>
<ol start="2">
<li><code>ETag/If-None-Match</code>：</li>
</ol>
<ul>
<li><code>ETag</code>：<strong>服务器在响应中</strong>包含的头部字段，是资源内容的唯一标识（一般是哈希值）。</li>
<li><code>If-None-Match</code>：<strong>浏览器在请求中</strong>包含的头部字段，表示上次请求时获取的 ETag 值。</li>
</ul>
<p><strong>协商缓存机制的工作流程</strong></p>
<ol>
<li>初次请求：</li>
</ol>
<ul>
<li>浏览器向服务器请求资源。</li>
<li>服务器返回资源和 <code>Last-Modified</code> 或 <code>ETag</code>。</li>
<li>浏览器缓存资源及其相关的头部信息。</li>
</ul>
<ol start="2">
<li>再次请求：</li>
</ol>
<ul>
<li>浏览器在请求中包含 <code>If-Modified-Since</code> 或 <code>If-None-Match</code>。</li>
<li>服务器根据这些头部信息判断资源是否被修改：<ul>
<li>如果未修改，返回 <code>304 Not Modified</code>，浏览器从缓存中读取资源。</li>
<li>如果已修改，返回新的资源和相应的 <code>Last-Modified</code> 或 <code>ETag</code>。</li>
</ul>
</li>
</ul>
<p><strong>协商缓存的优缺点</strong></p>
<ol>
<li>优点：</li>
</ol>
<ul>
<li><strong>节省带宽</strong>：未修改的资源不会再次传输，减少了网络流量。<br>保证资源最新：即使在缓存有效期内，资源有更新也能及时获取。</li>
<li><strong>保证资源最新</strong>：即使在缓存有效期内，资源有更新也能及时获取。</li>
</ul>
<ol start="2">
<li>缺点：</li>
</ol>
<ul>
<li><strong>服务器负载</strong>：每次请求都需要服务器进行验证，增加了服务器的负载。</li>
<li><strong>略微延迟</strong>：需要与服务器进行通信，可能会略微增加响应时间。</li>
</ul>
<h2 id="2-问题排查"><a href="#2-问题排查" class="headerlink" title="2. 问题排查"></a>2. 问题排查</h2><h3 id="2-1-故障描述"><a href="#2-1-故障描述" class="headerlink" title="2.1 故障描述"></a>2.1 故障描述</h3><p>浏览器访问服务器，加载完 html 文件后卡住，没有展示 loading 状态，也没有任何可交互的 UI 展示，呈现只有背景色的空白页。多次刷新页面也无法解决。打开控制台查看资源加载情况，如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-console.png"
                        alt="alt text"
                 ></p>
<h3 id="2-2-排查过程"><a href="#2-2-排查过程" class="headerlink" title="2.2 排查过程"></a>2.2 排查过程</h3><h4 id="2-2-1-问题分析"><a href="#2-2-1-问题分析" class="headerlink" title="2.2.1 问题分析"></a>2.2.1 问题分析</h4><p>正常情况下，进入页面时会显示加载状态，如果这都没显示，那很可能 js 脚本就根本没执行。再结合控制台的资源加载情况，发现作为程序入口的 <code>main.js</code> 确实没有被加载，但是 main.js 确实有在 <code>index.html</code> 中被引入，推测有什么东西阻塞了 <code>main.js</code> 的加载。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-html.png"
                        alt="alt text"
                 ></p>
<p>继续看控制台，发现除了我们项目中的 js 脚本以外，多了几个没见过的脚本，比如 <code>rocket-loader.min.js</code>、<code>invisible.js</code>，还有 rum 这个不知道是什么的接口。清除缓存刷新页面后，这几个脚本消失了，并且网页能够正常加载。于是推测这几个脚本很可能是本次事故的罪魁祸首。</p>
<h4 id="2-2-2-直接原因"><a href="#2-2-2-直接原因" class="headerlink" title="2.2.2 直接原因"></a>2.2.2 直接原因</h4><p>Google 一下 <code>rocket-loader</code>，得知它是 cloudflare 用于网站性能优化的一个脚本。它会推迟所有 js 脚本的加载，直至网页渲染完毕。推迟 js 脚本的加载这一行为，正好与 main.js 没有加载这一表现一 致。通过这一点合理怀疑是 <code>rocket-loader</code> 没有加载出来，导致 main.js 也没法正常加载执行。</p>
<p>从上面介绍的公司服务系统架构可以得知，从海外访问时会走 cloudflare。于是改 hosts 文件将公司服务器域名固定为 cloudflare 的 ip，访问后果然得到了<code>rocket-loader</code>。此时还可以正常访问。然后在控制台中将 <code>rocket-loader.min.js</code> 的访问请求 block 掉，成功复现事故。至此，可以确定是 <code>rocket-loader</code> 加载失败，导致呈现空白页。如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader.png"
                        alt="alt text"
                 ></p>
<p>从经典的三个 W（ what, why, how）出发，我们已经知道了它是什么，接下来探究一下 why 和 how。</p>
<h4 id="2-2-3-why：rocket-loader-为什么要这么做"><a href="#2-2-3-why：rocket-loader-为什么要这么做" class="headerlink" title="2.2.3 why：rocket-loader 为什么要这么做?"></a>2.2.3 why：rocket-loader 为什么要这么做?</h4><p>Cloudflare 说 <code>rocket-loader</code> 推迟 js 脚本的加载，是为了让网页能够更早渲染。这一点需要从网页的渲染流程说起。MDN 将<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#%E6%B8%B2%E6%9F%93" >网页渲染<i class="fas fa-external-link-alt"></i></a>分为五步，分别为构建 DOM 树、构建 CSSOM 树、构建渲染树、布局和绘制。</p>
<p>Rocket loader 作用的阶段在第一步——解析 HTML 和构建 DOM 树。在解析 HTML 的过程中，img 和 css 等标签不会影响它的进程，但是 js 脚本会。当 HTML 解析遇到 js 标签时，它会<strong>阻塞渲染并停止解析</strong>，直至 js 脚本文件<strong>下载并解析完成</strong>。其原因在于，js 脚本文件很有可能会修改 DOM 树。这也是我们推荐把 js 脚本放在 HTML 文档最后，或者加上 async&#x2F;defer 属性的原因。</p>
<p>总结：js 脚本会阻塞页面的渲染，Cloudflare 为了让页面尽早渲染，推迟了 js 脚本的执行，以优化(首屏加载时间) Time to First Paint (TTFP)等指标。</p>
<h4 id="2-2-4-how：rocket-loader-如何做到这一点的？"><a href="#2-2-4-how：rocket-loader-如何做到这一点的？" class="headerlink" title="2.2.4 how：rocket-loader 如何做到这一点的？"></a>2.2.4 how：rocket-loader 如何做到这一点的？</h4><p>Cloudflare 首先会将 html 中所有的 script 标签的 type，改写为随机字符串-text&#x2F;javascript。如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-script-type.png"
                        alt="alt text"
                 ></p>
<p>对于除了 <strong>Javascript MIME 类型</strong>、<strong>module</strong>、<strong>importmap</strong> 以外的 type 值，浏览器会忽略它，<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" >不去执行<i class="fas fa-external-link-alt"></i></a> 。因此，浏览器不再会执行我们在 <code>index.html</code> 中的所有 js 脚本。除了 Cloudflare 自己的脚本，比如 <code>rocket-loader</code>，它们是正常的 js 脚本，会被浏览器正常执行。</p>
<p>接下来所有的工作都会交给 <code>rocket-loader</code>。Rocket loader 首先会抓取页面中的所有 script 标签，然后将这些脚本作为 preload 的 link 标签，插入到 head 中。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-preload.png"
                        alt="alt text"
                 ></p>
<p>插入的脚本如下所示。这些脚本会被加载，但是不会被执行，也不会阻塞 DOM 树生成:</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-link.png"
                        alt="alt text"
                 ></p>
<p>然后 <code>rocket-loader</code> 会监听 window 的 load 事件，在 load 事件结束后，它将之前插入的 preload 的 link 标签删除，重新将这些脚本的 script 标签插入。这样，这些 js 脚本又会被正常执行了。也正因如此，rocket-loader 脚本一旦失效，我们的所有 js 脚本都会无法被执行。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-invalid.png"
                        alt="alt text"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-invalid02.png"
                        alt="alt text"
                 ></p>
<p>通过动态插入 link 标签，浏览器可以请求 js 脚本而不阻塞 DOM 树生成，同时也不会阻塞 DOMContentLoaded 事件和 load 事件，从而缩短页面加载的时间。</p>
<h4 id="2-2-5-rocket-loader-出什么问题了？"><a href="#2-2-5-rocket-loader-出什么问题了？" class="headerlink" title="2.2.5 rocket-loader 出什么问题了？"></a>2.2.5 rocket-loader 出什么问题了？</h4><p><code>rocket-loader</code> 加载失败是直接原因，我们只是通过 block 这一请求复现了事故。那么究竟在用户的浏览器中，为什么会出现<code>rocket-loader.min.js</code>这一资源 404 的情况呢？</p>
<p>仔细观察<code>rocket-loader.min.js</code>的请求地址，如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-request.png"
                        alt="alt text"
                 ></p>
<p>可以看到 <code>rocket-loader.min.js</code> 资源中 scr 的路径地址上有这么一段路径 <code>/cdn-cgi/</code>, 合理推测下，cloudflare 会拦截 <code>/cdn-cgi</code> 下的请求，并返回它自己的资源，这个请求不会被进一步转发到我们的 AWS 服务器上。</p>
<p>如果 <code>rocket-loader</code> 这一请求，被正确地发送到了 cloudflare 服务器，那肯定能正确返回这一资源，不会出现 404 的情况。那如果我们不通过 cloudflare，而是直接请求，或者通过 aliyun 去请求 <code>rocket-loader</code> 呢？尝试的结果如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-directrequest.png"
                        alt="alt text"
                 ></p>
<p>可以看到，由于没有 cloudflare 帮忙处理这一请求，这个请求会发到我们自家的服务器上，然而我们自己的服务器上显然是没有这个资源的，于是就会出现 302（尝试重定向）转 404 的情况。回到用户的事故截 图，发现也有 <code>rocket-loader</code> 302 转 404 的情况，这不就对上了吗！于是我们判断，<code>rocket-loader</code> 请求 404，是因为根本没有走 cloudflare。</p>
<p>上文提过，<code>rocket-loader</code> 是 cloudflare 给 html 插入的性能优化脚本。既然没有走 cloudflare，那为什么还会有 rocket-loader 存在呢？联想一下我们本次解决事故的方式——清缓存刷新，那么问题会不会是出在缓存呢？<code>rocket-loader</code> 是被插入到 <code>index.html</code> 中的，很有可能 <code>index.html</code> 被浏览器缓存了，浏览器一直在使用被插入了 <code>rocket-loader</code> 的 html，直至下一次 <code>index.html</code> 有更新（也就是版本发布）。</p>
<p>使用 CloudFare 版本的 <code>index.html</code>，却没有向 cloudflare 发送请求。难道浏览器在某一次走了 cloudflare 线路，缓存了 cloudflare 的 html 资源后，之后又回到了 aliyun 线路，但是依然沿用了 cloudflare 版本的 html？回到我们在背景中提到过的浏览器缓存机制。由于 <code>index.html</code> 的 <code>cache-control</code> 响应头中存在 <code>no-cache</code> 字段，浏览器必须每次使用缓存的资源之前，都与服务器进行协商。难道 aliyun 和 cloudflare 之间存在缓存同步机制？如果 aliyun 返回的 ETag 字段值是相同的，是不是会导致浏览器继续使用另一个云服务器返回的资源？</p>
<p>事实证明，确实如此。**CDN 云服务器没有为我们的 <code>index.html</code> 添加 ETag，它们的响应头里的 ETag，是我们自己的 nginx 服务器返回的。较新版本的 nginx 都会自动为所有静态资源创建 ETag。所采用 的算法为计算文件的最后修改时间的 16 进制，以及文件大小的 16 进制，并将它们通过短横连接<a class="link"   href="https://serverfault.com/questions/690341/algorithm-behind-nginx-etag-generation" >查看详情<i class="fas fa-external-link-alt"></i></a>。以当的 <code>index.html</code> 为例，ETag 为 ”64ec71f1-1957”，最后修改时间为 Mon, 28 Aug 2023 10:07:45 GMT，如图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-etag.png"
                        alt="alt text"
                 ></p>
<p>计算一下修改时间的 16 进制，会发现确实是 64ec71f1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="title function_">dayjs</span>(<span class="string">&#x27;Mon, 28 Aug 2023 10:07:45 GMT&#x27;</span>).<span class="title function_">unix</span>().<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str) <span class="comment">// 64ec71f1</span></span><br></pre></td></tr></table></figure>

<p>至此，我们基本可以确定本次事故的根本原因。</p>
<h3 id="2-3-问题总结"><a href="#2-3-问题总结" class="headerlink" title="2.3 问题总结"></a>2.3 问题总结</h3><p>作为问题定位的总结，我们来一步步分析一下该事故是如何发生的。</p>
<ol>
<li><p>用户在海外、或者在使用代理的情况下，访问网页，此时走的是 cloudflare 线路。浏览器获取到了带有 <code>rocket-loader</code> 的 <code>index.html</code> 并缓存下来,此时一切正常。</p>
</li>
<li><p>用户回到国内、或者关闭代理，访问网页，此时走的 aliyun 线路。浏览器带着 ETag 询问 aliyun 服务器是否能使用缓存下来的<code>index.html</code>，由于 ETag 相同，服务器告诉浏览器可以复用。于是 浏览器继续使用带有 <code>rocket-loader</code> 脚本的 <code>index.html</code>。</p>
</li>
<li><p><code>rocket-loader</code> 自身也有缓存，且支持强缓存。在有效期内（48 小时），浏览器可以直接复用 <code>rocket-loader</code>，而不用与服务器协商。此时请求 <code>rocket-loader</code> 不会报错，因为浏览器直接使 用了缓存,此时依然没有任何问题。</p>
</li>
<li><p>48 小时过后，<code>rocket-loader</code> 的缓存失效。此时用户再次访问网页，浏览器依然使用 cloudflare 提供的 <code>index.html</code>，但是它现在需要跟服务器协商是否能使用 <code>rocket-loader</code> 的缓存。但是此时走的不是 cloudflare 线路，显然 aliyun 和我们的 AWS 都不知道 rocket-loader 是什么，于是返回 404。</p>
</li>
<li><p><code>rocket-loader</code> 404，导致其他 js 资源无法正常加载，呈现空白页。直至用户清除 <code>index.html</code> 的缓存，或者在控制台中启用 Disable Cache 选项。</p>
</li>
</ol>
<p>为了重现事故，我于 8.29 下午 5 点通过 cloudflare 访问网页，并关闭 Disable Cache 选项。8.31 下午 5 点通过 aliyun 再次访问页面时，<code>rocket-loader</code> 和预期一致出现 404，并且页面呈现空白。和用户那边 的表现完全一致。如图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-rocket-loader-404.png"
                        alt="alt text"
                 ></p>
<h3 id="2-3-客户端临时解决方案"><a href="#2-3-客户端临时解决方案" class="headerlink" title="2.3 客户端临时解决方案"></a>2.3 客户端临时解决方案</h3><p>用户在当前页面清除缓存并强制刷新、或打开控制台并开启 Disable Cache 选项、或在浏览器设 置中清除浏览器缓存，即可解决问题。</p>
<h2 id="3-改进方案"><a href="#3-改进方案" class="headerlink" title="3. 改进方案"></a>3. 改进方案</h2><h3 id="再次发生的可能性分析"><a href="#再次发生的可能性分析" class="headerlink" title="再次发生的可能性分析"></a>再次发生的可能性分析</h3><p>在 Chrome 中新建一个用户，打开控制台观察 Disable Cache 选项，发现该选项时默认是未勾选的。也就是说，一般用户的浏览器都是会使用缓存的。那么用户一旦在国外和国内环境下分别访问了网页，就有很大的可能性遇到这一问题。不只是这个项目，我们的其他所有项目，都会出现这种情况，这是相当不妙的。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/cache/cache-chrome-cache.png"
                        alt="alt text"
                 ></p>
<h3 id="禁用-Rocket-loader？"><a href="#禁用-Rocket-loader？" class="headerlink" title="禁用 Rocket-loader？"></a>禁用 Rocket-loader？</h3><p>先看下 <code>rocket-loader</code> 对我们有何影响。按照 cloudflare 文档的说法，开启 <code>rocket-loader</code> 能大幅提升网站的响应速度，提升包括以下几方面：Time to First Paint (TTFP)，Time to First Contentful Paint (TTFCP)，Time to First Meaningful Paint (TTFMP)，Document Load。</p>
<p>不如我们直接来测试一下，分别走 aliyun 和 cloudflare 访问网页的情况下，加载速度究 竟有何不同。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">aliyun</th>
<th align="center">cloudflare</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DOMContentLoaded</td>
<td align="center">3.62</td>
<td align="center">0.50</td>
</tr>
<tr>
<td align="left">load</td>
<td align="center">4.31</td>
<td align="center">0.51</td>
</tr>
<tr>
<td align="left">页面完全呈现</td>
<td align="center">8.09</td>
<td align="center">5.44</td>
</tr>
</tbody></table>
<p>可以看出，走 cloudflare 的速度确实要快不少，尤其是 <code>DOMContentLoaded</code> 和页面 <code>load</code> 的时间。当然也不能排除我自己开了代理之后，有一定的加速效果。</p>
<p>加载速度的提升，除了会给用户良好的体验外，还会影响 google 搜索结果的排名。根据 google 的资料，网页的加载速度，如 Largest Contentful Paint (LCP)，会是 google 的排名系统所考虑的一项指标。</p>
<p>对于 <code>rocket-loader</code> 的负面评价也是有的。比如有人指出，<code>rocket-loader</code>会影响 ajax 和 js 动画；如果网站中有插入广告，那么广告脚本可能也会受影响<a class="link"   href="https://charbelnemnom.com/what-is-cloudflare-rocket-loader/" >详情<i class="fas fa-external-link-alt"></i></a> 。Cloudflare 自己的文档也说，如果你的网页中的 js 脚本加载出现问题，那么请禁用 <code>rocket-loader</code>。除此之外，国内访问 cloudflare 会较慢，因此多数程序员也是建议面向国内的网站直接禁用 <code>rocket-loader</code>。</p>
<h3 id="其他可能的方案"><a href="#其他可能的方案" class="headerlink" title="其他可能的方案"></a>其他可能的方案</h3><p>引起事故的其中一个原因，是走 aliyun 和 cloudflare 线路访问时，有可能使用的 <code>index.html</code> 是旧的， 没有使用最新的由 CDN 提供的 <code>index.html</code>。</p>
<p>由此启发想到两种方案：</p>
<ol>
<li><p>能否不使用我们的 nginx 提供的 ETag，而是由 CDN 服务器去创建 ETag？查阅资料后发现，Cloudflare 只是转发源服务器的 ETag，并没有提供创建 ETag 功能。<a class="link"   href="https://developers.cloudflare.com/cache/reference/etag-headers/" >详情<i class="fas fa-external-link-alt"></i></a> 。而 aliyun 没有相关文档说明，经确认后 aliyun 也不提供相关功能,此方案寄。</p>
</li>
<li><p>别惦记你那缓存了。既然两个 CDN 服务器提供的 <code>index.html</code> 不同，那么我们直接禁止浏览 器缓存 <code>index.html</code> 如何？正好 http 的 <code>Cache-Control</code> 响应头提供了这一功能，只要在其中带上 <code>no-store</code> 字段即可。并且观察后发现，<code>index.html</code> 的大小仅为 3-4 kb，即使每次都重新请求 ，对性能的影响也可以忽略不计。这可能是目前为止的最佳方案。</p>
</li>
</ol>
<hr>
<p><strong>参考资料</strong></p>
<ol>
<li><a class="link"   href="https://www.cloudflare.com/zh-cn/learning/cdn/what-is-a-cdn/" >什么是内容交付网络（CDN）？ | CDN 是如何工作的？<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching" >HTTP 缓存<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" >ETag 渲染页面：浏览器的工作原理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" >script：脚本元素<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developers.cloudflare.com/speed/optimization/content/rocket-loader/" >Rocket Loader<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://charbelnemnom.com/what-is-cloudflare-rocket-loader/" >What is Cloudflare Rocket Loader<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://developers.cloudflare.com/cache/reference/etag-headers/" >Using ETag Headers with Cloudflare<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
      <tags>
        <tag>performance</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>useCallback和闭包如何危害你的程序</title>
    <url>/2022/08/01/closures-useCallback-memory-leaks/index/</url>
    <content><![CDATA[<p>最近遇到了一个复杂的内存泄漏的问题，它是由 JavaScript 闭包和 React 的 <code>useCallback</code> 钩子的组合引起的。我花了相当长的时间才弄清楚发生了什么，所以我想分享一下我学到的东西。</p>
<p>我对闭包进行了简短的回顾，但如果您已经熟悉它们在 JavaScript 中的工作原理，请随意跳过这一部分。</p>
<h2 id="关于闭包的简要回顾"><a href="#关于闭包的简要回顾" class="headerlink" title="关于闭包的简要回顾"></a>关于闭包的简要回顾</h2><p>闭包是 JavaScript 中的一个基本概念。它们允许函数记住创建函数时作用域内的变量。这是一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> unused = <span class="number">0</span>; <span class="comment">// 这个变量没有在内部函数中被引用</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 这个变量在内部函数被引用了</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"><span class="title function_">counter</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">counter</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在此示例中， <code>createCounter</code> 函数返回一个可以访问 <code>count</code> 变量的新函数。这之所以能工作，是因为创建内部函数时， <code>count</code> 变量位于 <code>createCounter</code> 函数的词法作用域内部。</p>
<p>JavaScript 闭包是使用<strong>上下文对象（context object）</strong>实现的，该对象在函数最初<strong>创建时</strong>保存对作用域内变量的引用。哪些变量保存到上下文对象是 JavaScript 引擎的实现细节，并且需要进行各种优化。例如，在 Chrome 中使用的 JavaScript 引擎 V8 中，未使用的变量可能不会保存到上下文对象中。</p>
<p>由于闭包可以嵌套在其他闭包内，因此最里面的闭包将保存对它们需要访问的任何外部函数作用域的引用（通过所谓的作用域链）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstVar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这是引用了 first() 函数内变量的闭包</span></span><br><span class="line">    <span class="keyword">const</span> secondVar = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">third</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 这是引用了 second() 函数 和 first() 函数内变量的闭包</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(firstVar, secondVar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> third;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">second</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">first</span>(); <span class="comment">// 返回 third() 函数</span></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<p>在此示例中， <code>third()</code> 函数可以通过作用域链访问 <code>firstVar</code> 变量。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/react-closures-scopes.png"
                        alt="alt text"
                 ></p>
<p>因此，只要应用程序保存对该函数的引用，闭包作用域中的任何变量都不能被垃圾回收收集。由于作用域链，即使是外部函数作用域也将保留在内存中。</p>
<h2 id="React-和闭包"><a href="#React-和闭包" class="headerlink" title="React 和闭包"></a>React 和闭包</h2><p>对于所有函数式组件、钩子和事件处理程序，我们严重依赖 React 中的闭包。每当我们创建一个从组件范围访问变量（例如 state 或 props）的新函数时，很可能创建了一个闭包。下面是一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; id &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这是一个引用了 App 组件内 count 变量的闭包</span></span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id); <span class="comment">// 这是引用了props中id变量的闭包</span></span><br><span class="line">  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在大多数情况下，这本身并不是问题。在上面的示例中，<strong>App 的每次渲染都会重新创建新的闭包</strong>，并且旧的闭包将被垃圾收集。这可能意味着一些不必要的分配和释放，但仅仅这些分配和释放通常非常快。</p>
<p>但是，当我们的应用程序不断增长并且开始使用 <code>useMemo</code> 和 <code>useCallback</code> 等缓存技术来避免不必要的重新渲染时，有些事情需要特别的注意。</p>
<h2 id="useCallback-和闭包"><a href="#useCallback-和闭包" class="headerlink" title="useCallback 和闭包"></a>useCallback 和闭包</h2><p>通过记忆缓存钩子，我们可以用更好的渲染性能来换取更多的内存使用。只要依赖关系不改变， <code>useCallback</code> 将保存对函数的引用。让我们看一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleEvent = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ExpensiveComponent</span> <span class="attr">onEvent</span>=<span class="string">&#123;handleEvent&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们希望避免重新渲染 <code>ExpensiveChildComponent</code>。我们可以通过尝试保持 <code>handleEvent()</code> 函数引用稳定来做到这一点。我们使用 <code>useCallback</code> 将 <code>handleEvent()</code>进行记忆，以便仅在 <code>count</code> 状态更改时重新创建新的函数。然后，我们可以将 <code>ExpensiveChildComponent</code> 包装在 <code>React.memo()</code> 中，以避免在父级 <code>App</code> 渲染时重新渲染。到目前为止，一切都很好。</p>
<p>但让我们对这个例子进行一些修改：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigObject</span> &#123;</span><br><span class="line">    public readonly data = <span class="keyword">new</span> <span class="title class_">Unit8Array</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>); <span class="comment">// 10MB大小的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> bigData = <span class="keyword">new</span> <span class="title class_">BigObject</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleEvent = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, [count]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bigData.<span class="property">data</span>.<span class="property">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ExpensiveChildComponent2</span> <span class="attr">onMyEvent</span>=<span class="string">&#123;handleEvent&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你觉得会发生什么事情？</p>
<p>由于 <code>handleEvent()</code> 创建了一个引用 <code>App</code> 函数内 <code>count</code> 变量的闭包，因此它将<strong>保存对组件上下文对象的引用</strong>。而且，即使我—们<strong>从未在</strong> <code>handleEvent()</code> 函数中访问 <code>bigData</code> ， <code>handleEvent()</code> 仍将通过组件的上下文对象保存对 <code>bigData</code> 的引用。</p>
<p>所有闭包从创建之日起就<strong>共享一个公共上下文对象</strong>。由于 <code>handleClick()</code> 内部引用了 <code>bigData</code> ，因此 <code>bigData</code> 将由此上下文对象引用。这意味着，只要 <code>handleEvent()</code> 被引用， <code>bigData</code> 就永远不会被垃圾回收。此引用将一直保留，直到 <code>count</code> 更改并重新创建 <code>handleEvent()</code> 为止。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/react-closures-bigObjectCapture.png"
                        alt="alt text"
                 ></p>
<h2 id="useCallback-闭包-大数据对象-内存泄漏"><a href="#useCallback-闭包-大数据对象-内存泄漏" class="headerlink" title="useCallback + 闭包 + 大数据对象 &#x3D; 内存泄漏"></a>useCallback + 闭包 + 大数据对象 &#x3D; 内存泄漏</h2><p>让我们看一下最后一个例子，它将上述所有内容发挥到了极致。这个例子是我在我们的应用程序中遇到的简化版本。因此，虽然这个例子看起来有些做作，但它很好地说明了一般问题。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigObject</span> &#123;</span><br><span class="line">    public readonly data = <span class="keyword">new</span> <span class="title class_">Unit8Array</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>); <span class="comment">// 10MB大小的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [countA, setCountA] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [countB, setCountB] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> bigData = <span class="keyword">new</span> <span class="title class_">BigObject</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleClickA = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCountA</span>(countA + <span class="number">1</span>);</span><br><span class="line">    &#125;, [countA]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleClickB = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCountB</span>(countB + <span class="number">1</span>);</span><br><span class="line">    &#125;, [countB]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClickBoth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">handleClickA</span>();</span><br><span class="line">        <span class="title function_">handlClickB</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bigData.<span class="property">data</span>.<span class="property">length</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickA&#125;</span>&gt;</span>Increment A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickB&#125;</span>&gt;</span>Increment B<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickBoth&#125;</span>&gt;</span>Increment Both<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>A: &#123;countA&#125;, B: &#123;countB&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们有两个使用 <code>useCallback</code> 进行缓存处理的事件处理程序 <code>handleClickA()</code> 和 <code>handleClickB()</code> 。我们还有一个函数 <code>handleClickBoth()</code> ，它调用两个事件处理程序并打印 bigData 的长度。</p>
<p><strong>你能猜出当我们交替单击 Increment A 和 Increment B 按钮时会发生什么吗？</strong></p>
<p>让我们看看点击每个按钮 5 次后 Chrome DevTools 中的内存配置文件：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/bigobject-leak-useCallback.png"
                        alt="alt text"
                 ></p>
<p>似乎 <code>bigData</code> 永远不会被垃圾收集。内存使用量随着每次点击而不断增加。在我们的例子中，应用程序保存对 11 个 <code>BigObject</code> 实例的引用，每个实例大小为 10MB。一个用于初始渲染，一个用于每次单击。</p>
<ol start="0">
<li><strong>第一次渲染：</strong></li>
</ol>
<p>当 <code>App</code> 第一次渲染时，它会创建一个闭包函数作用域，其中包含对所有变量的引用，因为我们在至少一个闭包中使用了所有变量。这包括 <code>bigData</code> 、 <code>handleClickA()</code> 和 <code>handleClickB()</code> 。我们在 <code>handleClickBoth()</code> 中引用它们。我们将闭包范围称为 <code>AppScope#0</code> 。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/closure-chain-0.png"
                        alt="alt text"
                 ></p>
<ol>
<li><strong>单击 <code>Increment A</code> 按钮：</strong></li>
</ol>
<ul>
<li>第一次点击 <code>Increment A</code> 将导致 <code>handleClickA()</code> 被重新创建，因为我们更改了 <code>countA</code> :让我们将创建的函数称为 <code>handleClickA()#1</code>;</li>
<li><code>handleClickB()#0</code> 不会被重新创建，因为 <code>countB</code> 没有改变; 然而，这意味着 <code>handleClickB()#0</code> 仍将保留对先前 <code>AppScope#0</code> 的引用。</li>
<li>新的 <code>handleClickA()#1</code> 将保存对 <code>AppScope#1</code> 的引用，而 <code>AppScope#1</code> 则保存对 <code>handleClickB()#0</code> 的引用。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/closure-chain-1.png"
                        alt="alt text"
                 ></p>
<ol start="2">
<li><strong>单击 <code>Increment B</code> 按钮：</strong></li>
</ol>
<ul>
<li><p>第一次点击 <code>Increment B</code> 将导致 <code>handleClickB()</code> 被重新创建，因为我们更改了 <code>countB</code> ，从而创建了 <code>handleClickB()#1</code> 。</p>
</li>
<li><p>此时 React 不会重新创建 <code>handleClickA()</code> ，因为 <code>countA</code> 没有改变。</p>
</li>
<li><p>因此， <code>handleClickB()#1</code> 将保存对 <code>AppScope#2</code> 的引用，<code>AppScope#2</code> 保存着对 <code>handleClickA()#1</code> 的引用，同时<code>handleClickA()#1</code>保存着对<code>AppScope#1</code> 的引用，<code>AppScope#1</code> 保存着对<code>handleClickB()#0</code> 的引用 。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/closure-chain-2.png"
                        alt="alt text"
                 ></p>
</li>
</ul>
<ol start="3">
<li><strong>第二次单击“Increment A”按钮：</strong><br>这样，我们可以创建一个无限的闭包链，这些闭包相互引用并且永远不会被垃圾收集，同时拖着一个单独的 10MB <strong>bigData</strong> 对象，因为它会在每次渲染时重新创建。</li>
</ol>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/../../images/posts/closure-chain.png"
                        alt="alt text"
                 ></p>
<p>问题是单个组件中的不同 <code>useCallback</code> 钩子可能会通过闭包作用域相互引用或者引用一些其他昂贵的数据。然后，闭包将保存在内存中，直到重新创建 <code>useCallback</code> 钩子。组件中拥有多个 <code>useCallback</code> 钩子会使我们很难推断内存中保存的内容以及何时释放它。组件内的回调函数越多，遇到此问题的可能性就越大。</p>
<p><strong>这会是个问题吗？</strong></p>
<p>以下一些因素将使您更有可能遇到此问题：</p>
<ol>
<li>程序内存在一些几乎从未重新渲染的大型组件，例如，某个你将大量组件状态数据提升到的应用程序外壳组件。</li>
<li>大量依靠 <code>useCallback</code> 来最大限度地减少组件重新渲染。</li>
<li>在使用 <code>useCallback</code> 进行过缓存的函数内部调用了其他函数。</li>
<li>处理大型对象，例如图像数据或大型数组。</li>
</ol>
<p>如果你不需要处理任何大型对象，引用几个额外的字符串或数字可能不是问题。大多数这些闭包交叉引用将在足够的属性更改后被自动清除。不过，你的应用程序可能会占用比您预期更多的内存。</p>
<h2 id="如何避免闭包和-useCallback-造成内存泄漏？"><a href="#如何避免闭包和-useCallback-造成内存泄漏？" class="headerlink" title="如何避免闭包和 useCallback 造成内存泄漏？"></a>如何避免闭包和 useCallback 造成内存泄漏？</h2><p>一些避免此类问题的建议：</p>
<ul>
<li><strong>Tip1： 使闭包作用域尽可能小。</strong><br>JavaScript 使得发现所有被捕获的变量变得非常困难。避免保留太多变量的最佳方法是减少闭包周围的函数大小。这意味着：<ol>
<li>编写更小的组件，这将减少创建新闭包时范围内的变量数量。</li>
<li>编写自定义钩子，因为这样任何回调都只能关联在钩子函数的范围内。</li>
</ol>
</li>
<li><strong>Tip2： 避免捕获其他闭包，尤其是已经缓存的闭包。</strong><br>尽管这看起来很明显，但 React 很容易陷入这个陷阱。如果编写相互调用的较小函数，那么一旦添加第一个 <code>useCallback</code> ，就会出现<strong>要记住的组件范围内所有被调用函数</strong>这样的连锁反应。</li>
<li><strong>Tip3： 只要在非常必要的时候在考虑使用 React 的缓存技术</strong><br><code>useCallback</code> 和 <code>useMemo</code> 是避免不必要的重新渲染的好工具，但它们是有代价的。仅当您发现渲染导致的性能问题时才使用它们。</li>
<li><strong>Tip4（脱围机制）： 对于大型对象使用 <code>useRef</code></strong><br>这可能意味着，您需要自己处理对象的生命周期并正确清理它。虽然不是最优的，但比泄漏内存要好。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>闭包是 React 中广泛使用的模式。它们允许我们的函数记住组件上次渲染时范围内的 props 和 state 。当与 useCallback 等记忆技术结合使用时，这可能会导致意外的内存泄漏，尤其是在处理大型对象时。为了避免这些内存泄漏，请保持闭包范围尽可能小，在不必要时避免缓存记忆，对于大数据对象可能需要使用 useRef 。</p>
<p>希望这篇文章能在你使用 React 时帮助你进行更深入的思考。</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>performance</tag>
        <tag>memory-leaks</tag>
      </tags>
  </entry>
  <entry>
    <title>全面理解 Promise 系列（一)：Promise 基础</title>
    <url>/2022/04/01/promise/series-01/</url>
    <content><![CDATA[<p>虽然 Promise 通常与异步操作相关，但他其实只是值的“<strong>临时占位服务</strong>”，该值可能是已知的或更常见的是该值是一个异步操作的结果，所有函数都可以返回一个 Promise ，而不用像以前一样订阅(subscribe)一个事件或传递一个回调(callback)给该函数。举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetch() 承诺会在未来的某个时刻返回</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>fetch()</code>函数是 JavaScript 运行环境中的一个常见的实用函数，用来发出网络请求，<code>fetch()</code>实际上不会立刻完成该请求，而是过一会儿才完成。因此，该函数返回的是一个代表异步操作结果的 Promise （对象在本地中该 Promise 对象存储在名为 Promise 的变量中但<strong>其实你可以任意命名这个变量</strong>），这样你就可以在将来使用它，具体什么时候能使用这个结果，完全取决于该 Promise 的生命周期。</p>
<h2 id="1-1-Promise-的生命周期"><a href="#1-1-Promise-的生命周期" class="headerlink" title="1.1 Promise 的生命周期"></a>1.1 Promise 的生命周期</h2><p>每个 Promise 都会经历一个短暂的生命周期，这个生命周期从待定 <code>(pending)</code>状态开始，待定状态表明该 Promise 还没有完成。一个处于待定状态的 Promise 被认为是未确定的。在前面的例子中 Promise 在 <code>fetch()</code> 函数返回时就处于待定<code>(pending)</code>状态，一旦完成，该 Promise 就被视为已确定，并进入以下两种可能的状态之一:</p>
<ul>
<li>履行（fulfilled）状态：该 Promise 已经成功地完成了其承诺，并将其值作为结果返回。</li>
<li>拒绝（rejected）状态：该 Promise 由于错误或其他原因没有被成功完成， 也就是被拒绝了。</li>
</ul>
<p>内部属性<code>[[PromiseState]]</code>可以被设置为 <code>pending</code>、<code>fulfilled</code> 或 <code>rejected</code>反映 Promise 的状态，因为这个属性在 Promise 对象上是非公开的，所以我们无法通过编程来确定 Promise 处于哪个状态，不过我们可以在 Promise 的状态改变时通过<code>then()</code>方法来指定具体的行为。</p>
<h3 id="1-1-1-用-then-分配处理器"><a href="#1-1-1-用-then-分配处理器" class="headerlink" title="1.1.1 用 then() 分配处理器"></a>1.1.1 用 then() 分配处理器</h3><p><code>then()</code>方法存在于所有 Promise 中，它有两个参数。第一个参数是当 Promise 被履行时<code>(fulfilled)</code>要调用的函数，被称为<strong>履行处理器</strong>（fulfillment handler），任何异步操作被履行相关的额外数据都会作为参数被传递给这个函数。第二个参数是当 Promise 被拒绝时<code>(rejected)</code>要调用的函数，被称为<strong>拒绝处理器</strong>（rejection handler），任何与异步操作被拒绝相关的错误信息都会作为参数被传递给这个函数。</p>
<blockquote>
<p>💡 任何以上述方式实现 then() 方法的对象都被称为 <strong>thenable</strong> 对象。所有 Promise 对象都是 thenable，但并非所有 thenable 都是 Promise 。</p>
</blockquote>
<p>因为 <code>then()</code>的两个参数都是可选的，所以你可以选择性的监听履行状态、拒绝状态或者两者的任意组合。来看以下这组 <code>then()的</code>调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加履行处理器和拒绝处理器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// fulfilled</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request succeeded with response&#x27;</span>， response.<span class="property">status</span>);</span><br><span class="line">  &#125;，</span><br><span class="line">  (reason) =&gt; &#123;</span><br><span class="line">    <span class="comment">// rejected</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request failed with error&#x27;</span>， reason.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加另外一个履行处理器</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// fulfilled</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request succeeded with data&#x27;</span>， response.<span class="property">statusText</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加另外一个拒绝处理器</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="literal">null</span>， (reason) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request failed with error&#x27;</span>， reason.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3 个 <code>then()</code>调用都作用于同一个 Promise 对象，第一个 <code>then()</code>调用分配了一个履行处理器和一个拒绝处理器，第二个 <code>then()</code>调用只分配了一个履行处理器，该异步请求产生的错误不会报告给程序。第三个 <code>then()</code>调用只分配了一个拒绝处理器，该异步请求的成功完成不会被报告给程序。</p>
<blockquote>
<p>⚠️ <code>fetch()</code>函数的一个异常行为是：只要它收到一个 HTTP 状态码，哪怕是 404 或者 500，返回的 Promise 都会被视为 fulfilled，并将响应对象作为结果返回。只有当网络请求因为某种原因失败的时候， Promise 才会处于拒绝状态。因此，你需要在 <code>then()</code>调用中检查响应对象的状态码，已确定请求是否成功，如下所示：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request succeeded.&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request failed.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-用-catch-分配拒绝处理器"><a href="#1-1-2-用-catch-分配拒绝处理器" class="headerlink" title="1.1.2 用 catch() 分配拒绝处理器"></a>1.1.2 用 catch() 分配拒绝处理器</h3><p>Promise 还有一个名为 <code>catch()</code> 的方法。当只传递一个拒绝处理器时，它的行为与 <code>then()</code> 类似。比如下面的 <code>catch()</code> 调用和 <code>then()</code> 调用在功能上是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// rejected</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request failed with error&#x27;</span>， reason.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="literal">null</span>， (reason) =&gt; &#123;</span><br><span class="line">  <span class="comment">// rejected</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request failed with error&#x27;</span>， reason.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then()</code> 和 <code>catch()</code> 的根本目的是让你把它们结合起来使用，从而指明如何处理结果。这个组合比事件处理器和回调函数更好，因为它清楚地展示了操作成功与否。（事件处理器往往不会在出现错误时被触发， 而是在回调函数中，你必须随时记得检查可能出现的错误并手动处理。） 如果你不给一个被拒绝的 Promise 添加拒绝处理器， 那么 JavaScript <strong>运行环境</strong> （浏览器或 Node）就会向控制台输出一条错误消息， 或者抛出一个错误对象，又或者两者都有（具体取决于 JavaScript 运行环境）。</p>
<h3 id="1-1-3-用-finally-分配解决处理器"><a href="#1-1-3-用-finally-分配解决处理器" class="headerlink" title="1.1.3 用 finally() 分配解决处理器"></a>1.1.3 用 finally() 分配解决处理器</h3><p>除了<code>then()</code>和<code>catch()</code>， Promise 还有<code>finally()</code>， 无论异步操作是成功还是失败，只要操作完成， 那么传给<code>finally()</code>的回调函数(被称为<strong>解决处理器</strong>)就会被调用， 与传给<code>then()</code>和<code>catch()</code>的回调函数不同， <strong>传给<code>finally()</code>的回调函数不接受任何参数</strong>， 因为我们不清楚 Promise 是被履行了还是被拒绝了， 因为解决处理器在 Promise <strong>被履行和被拒绝时都会被调用</strong>， 所以它类似于使用<code>then()</code>时将同一个函数传递给 Promise 的履行处理器和拒绝处理器。以下是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我们不知道 Promise 是被履行还是被拒绝， 所以我们不接受任何参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request completed.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request completed.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(callback， callback);</span><br></pre></td></tr></table></figure>

<p>只要不访问回调函数的参数，这两个例子所表现出的行为就是一致的。然而，与<code>then()</code>相比，使用<code>finally()</code>可以更清晰地表达你的意图，这一点和<code>catch()</code>一样。</p>
<p>当你希望知道一个操作已经完成，但并不关心结果时，解决处理器很有用。举个例子，假设你想在<code>fetch()</code>请求处于活跃状态时在网页上显示一个加载指示器，然后在<code>fetch()</code>请求完成后隐藏该加载指示器。在这种情况下，该请求本身是否成功并不重要，因为一旦请求完成，加载指示器就应该隐藏。如下代码，可在你的 Web 应用程序中满足上述需求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> appElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">appElement.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理成功</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  appElement.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，AppElement 代表在网页上包裹整个应用程序的 HTML 元素。使用<code>fetch()</code>发起一个网络请求，添加 CSS 类 loading 到该 HTML 元素中(这样做便可以适当地改变该元素的样式)。当网络请求完成后， Promise 的状态已确定，解决处理器将该 loading 类从 HTML 元素中移除，以重置应用程序的状态。你仍然可以使用<code>then()</code>和<code>catch()</code>来响应请求成功和失败的结果， 而<code>finally()</code><strong>只处理状态从不确定到确定的变更</strong>。如果没有<code>finally()</code>，你就需要在履行处理器和拒绝处理器中都删除该 loading 类。</p>
<blockquote>
<p>⚠️ 注意: 通过<code>finally()</code>添加的解决处理器并不能避免由于请求被拒绝而向控制台输出或抛出错误， 你仍需要添加一个拒绝处理器来避免这种情况。</p>
</blockquote>
<h3 id="1-1-4-为已确定的-Promise-分配处理器"><a href="#1-1-4-为已确定的-Promise-分配处理器" class="headerlink" title="1.1.4 为已确定的 Promise 分配处理器"></a>1.1.4 为已确定的 Promise 分配处理器</h3><p>即使履行处理器、拒绝处理器或解决处理器是在 Promise 状态已确定的情况下添加的，该处理器也仍然会被执行。这样一来，你便可以在<strong>任何时候</strong>添加新的处理器和拒绝处理器，并确保它们会被调用。来看以下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来的履行处理器</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request succeeded&#x27;</span>， response.<span class="property">status</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在再添加另外一个新的履行处理器</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request succeeded&#x27;</span>， response.<span class="property">statusText</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，原来的履行处理器在同一个 Promise 上添加了另一个旅履行处理器，此时该 Promise 已经处于履行状态，所以新的履行处理器被添加到<strong>微任务</strong>（microtask）的队列中，并在就绪时被调用。拒绝处理器和解决处理器的工作方式也是如此。</p>
<h3 id="1-1-5-处理器和微任务"><a href="#1-1-5-处理器和微任务" class="headerlink" title="1.1.5 处理器和微任务"></a>1.1.5 处理器和微任务</h3><p>在常规的程序执行流程中，JavaScript 代码是被当作一个<strong>任务</strong>来执行的。也就是说，JavaScript 会创建一个新的执行环境，彻底的执行代码，并在完成后退出。比如，网页中的一个按钮对应的<code>onclick</code>处理器被当作一个任务来执行。当该按钮被点击时，JavaScript 会创建一个新的任务，并执行<code>onclick</code>处理器。一旦执行完成，JavaScript 就会原地待命，等待下一次用户交互来执行更多的代码。然而， Promise 的处理器则是以一种不同的方式来执行的。</p>
<p>所有的 Promise 处理器，无论是履行处理器，拒绝处理器，还是解决处理器，都被作为<strong>JavaScript 引擎</strong>内部的微任务执行。微任务被排在对列中，JavaScript 会在执行完当前任务后立即执行下一个任务。当 Promise 的状态确定后，对<code>then()</code>，<code>catch()</code>和<code>finally()</code>的调用<strong>会将指定的处理器排在微任务队列之中</strong>。这与通过 <code>setTimeout</code> 或 <code>setInterval</code> 创建定时器不同，这两个函数所创建的新任务会在之后某个时刻执行。在微任务队列中的 Promise 处理器则一定会在同一代码脚本任务中排队的定时器<strong>之前</strong>执行。你可以通过使用全局的 queenMicroTask 函数来测试这一点。该函数可用于在无 Promise 的情况下创建微任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Timer task&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Microtask task in timer&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;， <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Microtask&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个延迟为 0 毫秒的定时器，并在该定时器中创建了一个新的微任务。此外，这段代码还在定时器以外创建了一个微任务。当这段代码执行时，你会在控制台中看到以下输出内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Microtask&#x27;</span>;</span><br><span class="line"><span class="string">&#x27;Timer task&#x27;</span>;</span><br><span class="line"><span class="string">&#x27;Microtask task in timer&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>尽管定时器的延迟被设置为 0 毫秒，<strong>但微任务还是先于定时器执行</strong>，其次是定时器，最后才是定时器内的微任务。<strong>关于微任务(包括所有的 Promise 处理器)，最重要的一点是，它们会在主任务完成后立即执行。</strong> 这最大限度地缩短了解决 Promise 和对解决本身作出反应之间的时间间隔，从而使 Promise 适用于对运行时效有所要求的情况。</p>
<h2 id="1-2-创建未解决的-Promise"><a href="#1-2-创建未解决的-Promise" class="headerlink" title="1.2 创建未解决的 Promise"></a>1.2 创建未解决的 Promise</h2><p>新的 Promise 由 Promise 对象的构造函数来创建。这个构造函数接受一个被称为<strong>执行器</strong> (executor) 的函数作为参数。该执行器包含初始化 Promise 所需要的代码。执行器接受两个参数，是分别名为 <code>resolve</code> 和 <code>reject</code> 函数。当执行器完成以后，调用 <code>resolve()</code> 函数以表示 Promise 操作成功完成。当执行器操作失败时，则调用 <code>reject()</code> 函数以示 Promise 操作失败。<br>下面是一个使用旧的 XMLHttpRequest 浏览器<strong>应用程序接口</strong>的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">requestURL</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配事件处理器</span></span><br><span class="line">    xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: xhr.<span class="property">status</span>,</span><br><span class="line">        <span class="attr">text</span>: xhr.<span class="property">responseText</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">requestURL</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听履行和拒绝的状态</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 履行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，XMLHttpRequest 的调用被包裹在一个 Promise 中。<code>load</code> 事件表明该请求已经成功完成，因此 Promise 执行器在事件处理器中调用了 <code>resolve()</code>。与之类似，<code>error</code> 事件则表明该请求无法顺利完成，因此 Promise 执行器在该事件处理器中调用了 <code>reject</code>。你可以通过重复这个过程来将基于事件的功能转换为基于 Promise 的功能。</p>
<p><strong>执行器的重要性在于它在创建 Promise 时会立即运行</strong>。在之前的例子中，我们创建 xhr 对象，分配事件处理器，并在 Promise 从 <code>requestURL()</code> 返回之前启动调用。当执行器调用 <code>resolve()</code> 或 <code>reject()</code> 时， Promise 的状态和值被<strong>立即</strong>设置，但<strong>所有 Promise 处理器作为微任务将暂时不会执行</strong>，直到当前的脚本工作完成。假如你在执行器内部立即调用 <code>resolve()</code>，试想会发生什么?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Executor&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;End of script&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 Promise ，并立即调用了 <code>resolve()</code> 函数， Promise 被立即解决，没有任何延迟。然后，我们通过 <code>then()</code> 添加了一个履行处理器来输出操作结果。虽然在添加处理器的时候，该 Promise 已经被解决，但是输出结果仍然如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Executor&#x27;</span>;</span><br><span class="line"><span class="string">&#x27;End of script&#x27;</span>;</span><br><span class="line"><span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>这说明， Promise 的执行器首先同步运行并将 “Executor” 打印到控制台中。接着，履行处理器被添加，<strong>但是不会立即执行</strong>。这段代码会创建一个新的微任务，它将在当前脚本工作完成之后被执行。这意味着 <code>console.log(&#39;End of script&#39;)</code>这句代码会在执行履行处理器之前被执行，在当前脚本的其他部分完成后才输出 42。</p>
<blockquote>
<p>💡 <strong>一个 Promise 只能被解决一次</strong>。如果你在一个执行器中多次调用 <code>resolve()</code>，那么第一次调用之后的每一次调用都会被忽略。</p>
</blockquote>
<p><strong>执行器错误</strong>：如果执行器抛出错误，那么 Promise 的拒绝处理器就会被调用，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，执行器故意抛出一个错误。<strong>每个执行器内部都有一个隐式的 <code>try-catch</code> 块</strong>，如果执行器抛出错误，那么该错误会被捕获并交给拒绝处理器处理。前面的例子和如下的例子效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>执行器可以捕获任何被抛出的错误</strong>，从而简化这种常见的情况的处理流程。如果没有分配拒绝处理器，JavaScript 引擎就会抛出错误并停止运行当前程序。</p>
<h2 id="1-3-创建已解决的-Promise"><a href="#1-3-创建已解决的-Promise" class="headerlink" title="1.3 创建已解决的 Promise"></a>1.3 创建已解决的 Promise</h2><p>由于 Promise 执行器的行为是动态的，因此 Promise 对象的构造函数是创建<strong>未解决的 Promise</strong>的最佳工具。不过，如果想让 Promise 表示先前已经计算出的值，那么仅仅创建一个将值传递给 <code>resolve()</code> 或 <code>reject()</code> 的执行器变没有什么实际意义。有两个方法可以根据确定的值来创建已解决的 Promise。</p>
<h3 id="1-3-1-使用-Promise-resolve"><a href="#1-3-1-使用-Promise-resolve" class="headerlink" title="1.3.1 使用 Promise.resolve()"></a>1.3.1 使用 Promise.resolve()</h3><p><code>Promise.resolve()</code>方法接受一个参数并返回一个处于履行状态的 Promise 。这意味着如果你已经知道了 Promise 的值，就不必再提供执行器。来看一下这个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>自带代码创建了一个已履行的 Promise ，因此履行处理器会收到 42 这个值。和本章中的其他例子一样，履行处理器在当前脚本工作完成后作为一个微任务执行。如果给这个 Promise 添加了拒绝处理器，那么拒绝处理器将永远不会被调用，因为这个 Promise 永远不会处于拒绝状态。</p>
<p>如果你把一个 Promise 传递给<code>Promise.resolve()</code>，那么该方法就会返回你传递的那个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise1 === promise2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-使用-Promise-reject"><a href="#1-3-2-使用-Promise-reject" class="headerlink" title="1.3.2 使用 Promise.reject()"></a>1.3.2 使用 Promise.reject()</h3><p>你也可以通过使用<code>Promise.reject()</code>来创建处于拒绝状态的 Promise 对象。这与<code>Promise.resolve()</code>的工作原理类似，只不过创建的 Promise 是处于拒绝状态的，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">42</span>);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>添加的该 Promise 中的任何额外的拒绝处理器都会被调用，但履行处理器不会被调用，因为该 Promise 永远不会处于履行状态。</p>
<h3 id="1-3-3-非-Promise-的-thenable-对象"><a href="#1-3-3-非-Promise-的-thenable-对象" class="headerlink" title="1.3.3 非 Promise 的 thenable 对象"></a>1.3.3 非 Promise 的 thenable 对象</h3><p><code>Promise.resolve()</code>和<code>Promise.reject()</code>也接受非 Promise 的 thenable 对象作为参数。当传递一个非 Promise 的 thenable 对象时，这些方法会基于该 thenable 对象已确定的值和状态，创建一个新的 Promise 对象。</p>
<p>当一个对象有一个 <code>then()</code> 方法，并且可接参数 resolve 函数和 reject 函数作为参数，我们就认为该对象是一个非 Promise 的 thenable 对象，举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了 <code>then()</code> 方法,这个例子中的 thenable 对象没有其他与 Promise 对象相关联的特征。你可以通过调用<code>Promise.resolve()</code>来将 thenable 对象转换为处于履行状态的 Promise 对象:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Promise.resolve()</code>通过调用 <code>thenable.then()</code> 来确定该 Promise 的状态，因为在 <code>then()</code> 方法中调用了 <code>resolve(42)</code>，所以 thenable 的 Promise 对象处于履行状态。因此，以上代码创建了一个处于履行状态的 Promise 对象，名为 promise。该 Promise 对象的履行处理器接收来自 thenable 对象的 42，作为其值。</p>
<p>同理，可以用<code>Promise.resolve()</code>来从 thenable 创建一个处于拒绝状态的 Promise ，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子与上一个例子相似，只不过 thenable 对象处于拒绝状态。当 <code>thenable.then()</code> 执行时，它会创建一个处于拒绝状态的 Promise 对象，其值为 42，这个值会被传递给 Promise 的拒绝处理器。</p>
<p><code>Promise.resolve()</code> 和 <code>Promise.reject()</code>的这种功能使得它们成为处理非 Promise 值和 thenable 对象的有用工具。在 2015 年 ECMAScript 引入 Promise 之前，很多库使用 thenable 对象。 因此， 能够将 thenable 对象转换为 Promise 对象对于兼容之前的库来说非常重要。</p>
<p>当你不确定一个对象是否是一个 Promise 时，通过 <code>Promise.resolve()</code> 或 <code>Promise.reject()</code> 传递该对象是找出答案的最佳方法，因为 Promise 只会被原样传回。</p>
<h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><ul>
<li>Promise 是值的”<strong>临时站位符</strong>“，这个值将在以后某个时间点作为某个异步操作的结果来提供给当前程序。 你可以使用 Promise 来表示操作的结果，而无需使用事件处理器或回调函数。</li>
<li>Promise 有三种状态：待定<code>(pending)</code>、履行<code>(fulfilled)</code>和拒绝<code>(rejected)</code>。一个 Promise 从待定状态(未确定的状态)开始，在成功执行时进入履行状态，在失败时进入拒绝状态。（履行状态和拒绝状态都是已确定的状态）无论是哪种情况都可以通过添加处理器来表明该 Promise 的状态已确定。</li>
<li><code>then()</code>方法可以用于分配履行处理器和拒绝处理器，<code>catch()</code> 方法可用于分配拒绝处理器。<code>finally()</code>方法可用于分配解决处理器。无论操作结果是成功还是失败，解决处理器<code>(finally)</code>都会被调用。</li>
<li>因为所有的 Promise 处理器都是被作为<strong>微任务</strong>来执行的，所以他们在当前脚本工作完成之前不会执行。</li>
<li>你可以使用构造函数来创建处于未确定状态的 Promise 对象，该构造函数接受一个执行器函数（Executor）作为其唯一的参数。执行器函数被传入<code>resolve</code>和<code>reject</code>两个参数，分别用以表明 Promise 是成功还是失败。</li>
<li><strong>执行器在创建 Promise 时立即执行</strong>。这与被作为微任务运行的处理器不同，执行器抛出的任何错误都会被自动捕获并传递给 reject。</li>
<li>可以使用 <code>Promise.resolve()</code> 来创建处于履行状态的 Promise，或使用 <code>Promise.reject()</code> 来创建处于拒绝状态的 Promise。 这两个方法都会把传入的参数包裹在 Promise 中(如果该参数不是一个 Promise 对象，也不是一个非 Promise 的 thenable 对象)，并创建一个新的 Promise 对象，或将原来的 Promise 对象原样传递。当你不确定某对象是否是 Promise，但又希望它表现得像 Promise 时，这些方法很有帮助。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>全面理解 Promise 系列（二)：链式 Promise</title>
    <url>/2022/04/10/promise/series-02/</url>
    <content><![CDATA[<p>到目前为止， Promise 可能看起来只不过是结合回调函数和 <code>setTimeout()</code> 所做的渐进式改进，但其意义远比表面看起来丰富的多。具体地说，我们可以用多种方法将 Promise 链接起来，以实现更复杂的异步功能。</p>
<p>实际上，对<code>then()</code>、<code>catch()</code>或<code>finally()</code>的每次调用都会创建并返回另一个 Promise。只有在第一个 Promise 被履行或者被拒绝之后，第二个 Promise 的状态才能确定。参考以下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// Finished</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>promise.then()</code> 会返回第 2 个 Promise， 并在这个新的 Promise 上再次调用 <code>then()</code> 。 只有在第 1 个 Promise 被解决之后，第 2 个 <code>then()</code> 里的履行处理器才会被调用。如果将本例<strong>解链</strong>，就会得到如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line">promise2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这段非链式版本的代码中， <code>promise1.then()</code> 的结果被存储在 promise2 中，然后调用<code>promise2.then()</code> 来添加最后的履行处理器。对 <code>promise2.then()</code> 的调用也会返回一个新的 Promise，只不过我们没有用它。</p>
<h2 id="2-1-捕获错误"><a href="#2-1-捕获错误" class="headerlink" title="2.1 捕获错误"></a>2.1 捕获错误</h2><p>使用链式 Promise 有利于捕获之前 Promise 中的履行器或者拒绝处理器所产生的错误。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Oops&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>); <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中， promise 的履行处理器抛出了一个错误。在第 2 个 Promise 上对 <code>catch()</code> 的链式调用，能够通过拒绝处理器接受该错误。如果是拒绝处理器抛出错误，那么情况也一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Uh oh！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">message</span>); <span class="comment">// &quot;Uh oh！&quot;</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Oops&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>); <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>执行器抛出的错误出发了拒绝处理器。然后，拒绝处理器又抛出了一个新的错误，这个错误被第 2 个 Promise 的拒绝处理器捕获。<strong>链式 Promise 中拒绝处理器的调用能够感知链中其他 Promise 抛出的错误。</strong></p>
<p>我们可以利用链式 Promise 的这种能力来捕获错误，使之有效的起到类似于 try-catch 语句的作用。假如使用 <code>fetch()</code> 来获取一些数据，并希望捕获发生的错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理成功的响应</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理失败的原因</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子将在 <code>fetch()</code> 调用成功时输出相应状态，在调用失败的时候输出错误消息。我们可以进一步通过检查 resposne.ok 属性来将范围 200 ～ 299 之外的状态码作为错误抛出，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理成功的响应</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将错误抛出</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">`Request failed with status code <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理失败的原因</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在本例中，对 <code>catch()</code> 的调用注册了一个拒绝处理器。<strong>该拒绝处理器既可以捕获 <code>fetch()</code> 调用返回的错误，也可以捕获第一个履行处理器抛出的错误。</strong> 也就是说，<strong>我们可以仅仅使用一个拒绝处理器来处理链式 Promise 中可能发生的所有错误</strong>，而无需使用两个处理器来捕获不同类型的错误。</p>
<blockquote>
<p>💡 始终在链式 Promise 的末端添加一个拒绝处理器。这样做可以确保正确的处理链式 Promise 中可能发生的任何错误。</p>
</blockquote>
<h2 id="2-2-在链式-Promise-中使用-finally"><a href="#2-2-在链式-Promise-中使用-finally" class="headerlink" title="2.2 在链式 Promise 中使用 finally()"></a>2.2 在链式 Promise 中使用 finally()</h2><p><code>finally</code> 的表现与 <code>then()</code> 和 <code>catch()</code> 不同。<strong>它将前一个 Promise 的状态和值复制到其返回的 Promise 中。</strong> 这意味着如果原来的 Promise 处于履行状态，那么 <code>finally()</code> 会返回一个同样处于履行状态且值相同的 Promise。 来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finally called.&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，因为 <code>finally()</code> 注册的处理器不接受参数，无法接受 promise 的值，所以该值被复制到由于调用 <code>finally()</code> 而新创建的 Promise 中。 新的 Promise 履行的值是 42（从原 Promise 复制过来），因此 <code>then()</code> 处理器被调用，接受 42 作为参数。需要注意的是，<strong>即使新的 Promise 和 原 Promise 有着相同的值，它们并不是同一个对象</strong>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finally called.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise2.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise1 === promise2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，从 <code>promise1.finally()</code> 中返回的值被存储在 promise2 中。由此可知， promise1 和 promise2 并不是同一个对象。<strong>对 <code>finally()</code> 的调用总是从原 Promise 复制状态和值</strong>。这也意味着，当 <code>finally()</code> 在一个被拒绝的 Promise 上被调用时，它也会返回一个处于拒绝状态的 Promise。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finally called!&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子中的 promise 处于拒绝状态，且拒绝理由是 43。和之前的例子一样，解决处理器无法获取该信息，因为 <code>finally()</code> 没有可以传入的参数。因此它返回了一个新的 Promise，且该 Promise 因同样的理由被拒绝。之后我们可以通过使用 <code>catch()</code> 来检索该 Promise 被拒绝的理由。</p>
<p>当解决处理器<strong>抛出错误</strong>或者<strong>返回处于拒绝状态的 Promise</strong> 时，<code>finally()</code> 存在一个例外情况。<strong>在这种情况下，<code>finally()</code> 返回的 Promise 并不保持原 Promise 的状态和值。</strong>，而是以抛出的错误为理由变为拒状态，来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line">promise1</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">44</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason); <span class="comment">// 44 而不是 43</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">43</span>);</span><br><span class="line">promise2</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason); <span class="comment">// 44 而不是 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这例子中，因为解决处理器抛出 44 或者返回了 <code>promise.reject(44)</code> ，所以被返回的 Promise 处于拒绝状态，并且其值为 44 而不是 43。<strong>由于解决处理器抛出了错误，因此原 Promise 的状态和值就丢失了。</strong></p>
<p>在系列（一）中，我们举例了如何使用解决处理器根据对 <code>fetch()</code> 的调用来切换应用程序的加载状态。现在我们使用链式 Promise 重写这个例子，并加入一些错误处理技巧， 如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> appElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">appElement.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">`Request failed with status code <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    appElement.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>与 try-catch 语句不同，我们不希望 <code>finally()</code> 成为链式 Promise 的最后一环，以防 <code>finally()</code> 抛出错误。因此，<strong>应该首先调用<code>then()</code>,以处理来自<code>fetch()</code>的响应，然后在链中添加<code>finally()</code>来触发 UI 变化，最后通过<code>catch()</code>来添加整条链的错误处理器。</strong> 这里体现了解决处理器传递前一个 Promise 的状态的用处：如果履行处理器最终抛出一个错误，那么解决处理器(finally())将把该状态进一步传递给<code>catch()</code>,以便拒绝处理器访问该状态。</p>
<h2 id="2-3-从链式-Promise-返回值"><a href="#2-3-从链式-Promise-返回值" class="headerlink" title="2.3 从链式 Promise 返回值"></a>2.3 从链式 Promise 返回值</h2><p>链式 Promise 的另外一个重要的能力是将数据从一个 Promise 传递给下一个 Promise。我们已经知道，执行器（executor）内部如果调用 <code>resolve()</code>, 传递个 resolve 的参数会被传递给该 Promise 的履行处理器。我们可以通过指定履行处理器的返回值来继续沿着链式 Promise 传递数据，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>; <span class="comment">// 我们显式的返回一个值</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 的履行执行器在执行的时候返回了 value + 1。虽然 value 的值是 42（来自执行器），但是该履行处理器实际上返回了 43。然后这个值被继续传递给第二个 Promise 的履行处理器。<br>我们可以使用拒绝处理器完成同样的工作。拒绝处理器在被执行的时候也可以显式的返回一个值。如果是这样，那么这个值就会传递给履行链中的下一个 Promise， 如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason); <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>; <span class="comment">// 我们显式的返回一个值</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>我们在此创建了一个处于拒绝状态且值为 42 的 Promise，这个值被传递给该 Promise 的拒绝处理器 拒绝处理器将返回 value + 1，虽然这个返回值来自拒绝处理器，但是它仍可被用于链中下一个 Promise 的履行处理器，如有必要，在链中的某一个 Promise 失败后，我们能够利用这一特点来恢复整条 Promise 链的操作。然而，使用 <code>finally()</code>会得到不同的结果,<strong>从解决处理器返回的任何值都会被忽略</strong>，这样一来，我们就可以访问原 Promise 的值。来看以下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">43</span>; <span class="comment">// 会被忽略</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，最终传递给履行处理器的值是 42，而不是 43。因为解决处理器中返回语句被忽略了, 所以我们才可以用 <code>then()</code> 检索到上层 promise 传递来的原始值。这是调用 <code>finally()</code> 返回由复制上层 promise 状态和值所创建的 promise 的后果之一。</p>
<h2 id="2-4-从链式-Promise-中返回-Promise"><a href="#2-4-从链式-Promise-中返回-Promise" class="headerlink" title="2.4 从链式 Promise 中返回 Promise"></a>2.4 从链式 Promise 中返回 Promise</h2><p>从 Promise 的处理器返回上层数据,使得我们能够在链中的多个 Promise 之间传递数据。 如果处理器返回的是一个对象,结果又会如何呢? 如果该对象是一个 Promise,那么我们需要一个额外的步骤来决定接下来该如何做。 考虑下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> promise2; <span class="comment">// 我们返回了一个 Promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中, promise1 被履行为 42, promise1 的履行处理器返回 promise2,这是一个已经处于履行状态的 promise, 第二个履行处理器之所以被调用是因为 promise2 处于履行状态, 如果 promise2 被拒绝,那么调用的就应该是拒绝处理器,而不是履行处理器。</p>
<p>关于这种模式,需要认识到的重要一点是, 第二个履行处理器并非被添加到 promise2 上, 而是被添加到第三个 Promise 上, 前面的代码等同于以下这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">const</span> promise3 = promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise3.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 43</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>很明显,第二个履行处理器被添加到了 promise3 上, 而没有被添加到 promise2 上。 这是一个微妙但重要的细节, 因为如果 promise2 被拒绝, 那么第二个履行处理器将不会被调用。 来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> promise2; <span class="comment">// 我们返回了一个 Promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 永远不会被调用</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>由于 promise2 被拒绝,因此这里调用了拒绝处理器。 promise2 的值 43 被传递给该拒绝处理器。</p>
<p>当一个操作需要不止一个 Promise 时, 从履行处理器返回 Promise 会很有用。 比如,<code>fetch()</code> 需要第二个 Promise 来读取响应主体。要读取一个 JSON 主体, 我们需要使用 <code>response.json()</code>, 它返回另一个 Promise。 以下是不使用链式 Promise 的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = response.<span class="title function_">json</span>();</span><br><span class="line">    promise2</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码需要两个拒绝处理器来分别捕获两个步骤中可能出现的错误。 要简化代码,我们可以从第一个履行处理器返回第二个 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title function_">fetch</span>(<span class="string">&#x27;book.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(reason.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这里,当收到响应时,第一个履行处理器就会被调用,该履行处理器会返回另外一个 Promise,以 JSON 格式读取响应主体。当主体被读取并且有效数据准备就绪时,第二个履行处理器就会被调用。我们只需要在链式 Promise 的末端添加一个拒绝处理器,来捕获整个过程中可能发生的错误。</p>
<p>使用<code>finally()</code>从解决处理器返回 Promise 的效果与使用<code>then()</code>和<code>catch()</code>不同。 除非<code>finally()</code>解决处理器抛出错误,或者返回一个处于拒绝状态的 Promise,否则其他任何的返回值（无论是返回一个普通的值还是返回一个 处于履行状态的 Promise）都会被忽略。 而原 Promise 的值将被采用， 如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">43</span>); <span class="comment">// 返回一个处于履行状态的 Promise, 会被忽略</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中,解决处理器返回了一个处于履行状态的 Promise， 值为 43, 但是下一个履行处理器接受到的值是原 promise 的值,即 42。</p>
<p>然而,如果我们从解决处理器返回一个处于拒绝状态的 promise, 那么该解决处理器返回的 promise 也会处于拒绝状态,如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>); <span class="comment">// 返回一个处于拒绝状态的 Promise，会向下传递</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>即使原 promise 是拒绝状态，这一点也成立，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>); <span class="comment">// 返回一个处于拒绝状态的 Promise，会向下传递</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>从解决处理器返回处于拒绝状态的 Promise 在功能上等同于抛出错误,返回的 Promise 因某个具体的理由而被拒绝。</p>
<p>从履行处理器或拒绝处理器返回 Promise 并<strong>不改变 Promise 执行器的执行时间</strong>。第一个 Promise 将首先运行其执行器,接着第二个 Promise 将运行其执行器,以此类推。通过返回 Promise,我们可以对 Promise 的结果定义额外的响应。要推迟履行处理器的执行时间,我们可以在一个履行处理器中创建新的 Promise,如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value + <span class="number">1</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 43</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>我们在 promise1 的履行处理器中创建了一个新的 Promise。这意味着第二个履行处理器只有在 promise2 被履行后才执行。promise2 的执行器使用 setTimeout 在 1000 毫秒后解决这个 Promise。实际情况是,我们可能会发起网络请求或文件系统请求。如果我们想在开始一个新的异步操作之前,等待之前的 Promise 确定其状态,那么这种模式会很有用。</p>
<h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><ul>
<li>我们可以通过各种方式链接多个 Promise, 以在它们之间传递信息。 对<code>then()</code>、<code>catch()</code>和<code>finally()</code>的每次调用都会创建并返回一个新的 Promise, 只有当之前的 Promise 被解决时,该 Promise 才会被解决。如果 Promise 处理器返回一个普通的值, 那么这个值将成为这个处理器所创建的 Promise 的值（finally 注册的处理器返回一个普通的值会被忽略）。如果 Promise 处理器抛出一个错误, 那么这个错误会被捕获,并且返回的新的 Promise 将因这个错误而被拒绝。</li>
<li>当一条链上的一个 Promise 被拒绝时, 链上的其他处理器所创建的 Promise 也都会被拒绝, 直到到达链的末端。鉴于此,我们建议在每条 Promise 链的末端都附加一个拒绝处理器, 以确保错误得到正确处理。没有捕获被拒绝的 Promise 将导致控制台输出错误消息, 或者抛出错误,一或者两者都有,取决于运行环境。</li>
<li>我们可以从处理器返回 Promise，在这种情况下 对 Zen 和 Catch 的调用 所返回的 Promise 的状态和值取决于处理器中显式返回的 promise。（<code>finally()</code>处理器是个例外， 如果显式返回了一个处于履行状态的 promise 将会被忽略， 而显式返回处于拒绝状态的 promise 则会被继续往下传递）。我们可以利用这一点，将一些操作延迟到某个 Promise 履行之后再启动，并返回第二个 Promise 从而继续使用同一条 Promise 链。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>全面理解 Promise 系列（三)：多个 Promise 协同工作</title>
    <url>/2022/04/17/promise/series-03/</url>
    <content><![CDATA[<p>我们有时候希望通过监听多个 Promise 的进展来确定下一步的行动。 JavaScript 提供了几种方法来监听多个 Promise,并以略微不同的方式对它们做出响应。</p>
<h2 id="3-1-Promise-all"><a href="#3-1-Promise-all" class="headerlink" title="3.1 Promise.all()"></a>3.1 Promise.all()</h2><p><code>Promise.all()</code> 方法可以接受一个 <strong>iterable</strong> （例如数组）作为参数，该参数包含所需要监听的 Promise， 并返回一个 Promise。当且仅当该 iterable 对象中的每个 Promise 都被履行（fulfilled）时，它才会返回一个处于履行状态（fulfilled）的 Promise。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">43</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(result)); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>]); <span class="comment">// 42</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">1</span>]); <span class="comment">// 43</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">2</span>]); <span class="comment">// 44</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里的每个被履行的 promise 都有相对应的一个值, 对 <code>promise.all()</code> 的调用创建了 promise4。 当 promise1, promise2 和 promise3 都被履行时, promise4 才会被履行。传递给 promise4 的履行处理器的是一个包含 42,43,44 的数组, 这些值是按照传递给 <code>promise.all()</code>的 promise 的顺序存储的。这样一来, 我们就可以将 promise 的结果与履行它们的 promise 相匹配。</p>
<p>如果传递给 <code>promise.all()</code> 的某个 promise 被拒绝, 那么返回的 promise 会被<strong>立刻拒绝</strong>,而不会等待其他的 promise 执行完成:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(reason)); <span class="comment">// false</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 43</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中,第二个 promise 被拒绝,其值为 43。 promise4 的拒绝处理器被<strong>立即调用</strong>, 而不是等待第一个 Promise 或第三个 Promise 执行完成。 (它们仍然会执行完成,只不过 Promise4 不会等待执行结果。) _拒绝处理器总是接收单一的值,而不是接收数组_。 这个值是被拒绝的 Promise 的值。在本例中,我们传递给拒绝处理器的值为 43,以表明拒绝来自 promise2。</p>
<blockquote>
<p>⚠️ iterable 参数中的任何非 Promise 值都会被传递给 <code>Promise.resolve()</code> 并被转换为 Promise。</p>
</blockquote>
<h3 id="3-1-1-何时使用-Promise-all-方法"><a href="#3-1-1-何时使用-Promise-all-方法" class="headerlink" title="3.1.1 何时使用 Promise.all() 方法"></a>3.1.1 何时使用 Promise.all() 方法</h3><p><code>Promise.all()</code> 适用于任何需要等待多个 Promise 履行的情况，这其中任何一个 Promise 被拒绝都会导致整个操作失败，下面介绍 <code>Promise.all()</code> 的一些常见用例</p>
<ol>
<li><strong>同时处理多个文件</strong></li>
</ol>
<p>当使用如 Node.js 或 Deno 这样的服务器端 JavaScript 运行环境时,我们可能需要读取多个文件以处理其中的数据。在这种情况下,最高效的做法是<strong>并行读取文件</strong>，并等待它们全部被读取后再继续处理数据。下面是一个在 Node.js 中读取文件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFiles</span>(<span class="params">filenames</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(filenames.<span class="title function_">map</span>(<span class="function">(<span class="params">filename</span>) =&gt;</span> <span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf8&#x27;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFiles</span>([<span class="string">&#x27;file1.json&#x27;</span>, <span class="string">&#x27;file2.json&#x27;</span>, <span class="string">&#x27;file3.json&#x27;</span>])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">fileContents</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 JSON 数据</span></span><br><span class="line">    <span class="keyword">const</span> data = fileContents.<span class="title function_">map</span>(<span class="function">(<span class="params">fileContent</span>) =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(fileContent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行必要的处理</span></span><br><span class="line">    cnosole.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子使用 Node.js 基于 Promise 的文件系统 API 来并行读取多个文件。<code>readFiles()</code>函数接受一个由待读取文件名组成的数组作为参数, 然后将每个文件名映射到 入<code>readFile()</code> 函数创建的 Promise 对象。文件以文本形式读取。(这一点从第二个参数 <code>utf8</code> 可知)。其读取结果在履行处理器中作为<code>fileContents</code> 数组可用,其中包含每个文件中的文本。在这里,文件内容被解析为 JSON 格式并存储在 data 数组中, 然后再被传递给处理数据的函数。这是处理多个文件的常用方法, 因为如果任何一个文件不能被读取或解析, 那么整个操作就不能正确完成,应该及时停止。</p>
<ol start="2">
<li><strong>调用多个相互依赖的 Web 服务 API</strong></li>
</ol>
<p><code>Promise.all()</code> 的另一个常见用例是调用多个相互依赖的 Web 服务 API, 这在 REST API 中尤为常见，因为与实体相关的每一种数据类型都可能有自己的端点。考虑这样一个场景：每个用户都拥有博客文章和相册，我们需要在用户的个人资料中展示这些信息。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_BASE</span> = <span class="string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/posts`</span>,</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/albums`</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> <span class="title function_">fetch</span>(url)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createError</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">    <span class="string">`Unexpected status code: <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span> for <span class="subst">$&#123;response.url&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">responses</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">      responses.<span class="title function_">map</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title function_">createError</span>(response));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [posts, albums] = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行必要的处理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(posts);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(albums);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure>

<p>在以上代码中,我们为每个用户提供端点 <code>/posts</code> 和 <code>/albums</code>。<code>fetchUserData()</code>函数接受一个用户 ID 并生成要调用的 URL。接着 URL 被映射到每个<code>fetch()</code>调用所返回的 Promise。当收到响应后,另一个<code>Promise.all()</code> 调用将每个响应映射到另一个 Promise。这个 Promise 要么是 JSON 正文（如果响应状态码介于 200 和 299 之间）,要么是处于拒绝状态的 Promise,这将中断整个操作并调用拒绝处理器。在最后的履行处理器中, posts 和 albums 的数据准备就绪,等待处理。</p>
<ol start="3">
<li><strong>人为引入延迟</strong></li>
</ol>
<p>有时我们想延迟一些事情的发生，与服务器端相比，这种情况更可能发生在浏览器端。比如我们有时需要在用户操作和响应之间引入延迟。具体的说，我们可能想在从服务器获取数据期间显示一个加载指示器。但如果响应太快，那么用户可能看不到加载动画，因而无法判断屏幕上的数据是否为最新数据。在这种情况下，我们可以人为引入延迟如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_BASE</span> = <span class="string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> appElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">mileseconds</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(), mileseconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  appElement.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> urls = [</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/posts`</span>,</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/albums`</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([...urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> <span class="title function_">fetch</span>(url)), <span class="title function_">delay</span>(<span class="number">2000</span>)]).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 去除 delay() 中的未定义结果</span></span><br><span class="line">      <span class="keyword">return</span> results.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createError</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">    <span class="string">`Unexpected status code: <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span> for <span class="subst">$&#123;response.url&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">responses</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">      responses.<span class="title function_">map</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title function_">createError</span>(response));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [posts, albums] = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行必要的处理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(posts);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(albums);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    appElement.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure>

<p>这段代码在前一个例子的基础上，为每一个 <code>fetch()</code> 调用引入了延迟。<code>delay()</code> 函数返回一个 promise。该 promise 会在指定的毫秒数过去后履行，实现方法是使用 <code>setTimeout()</code> 函数，并传递一个调用 <code>resolve()</code> 的回调函数。请注意，这种情况下，无需向 <code>resolve()</code> 传递任何值，因为没有相关数据。</p>
<blockquote>
<p>⚠️ 我们也可以直接将 resolve 作为第一个参数传递给 <code>setTimeout()</code>。但是某些 javascript 运行环境会向超时回调函数传递参数。为了在各种运行环境中实现最佳的兼容性，最好从另一个函数内部调用 <code>resolve()</code>。</p>
</blockquote>
<p><code>fetchUserData()</code> 函数发起对指定用户 ID 的 Web 服务请求。 和之前的例子一样，<code>promise.all()</code> 被用来同时监控多个 fetch 请求。但在这个例子中，传递给 <code>promise.all()</code> 的 promise 数组还包含对 <code>delay()</code> 的调用。当返回的 promise 被履行时，履行处理器会收到包含所有结果的数组。其中最后一个元素是 undefined。在最终结果从 <code>fetchUserData()</code> 返回之前移除最后一个元素，这样调用 <code>fetchUserData()</code>的代码就根本不需要知道 <code>delay()</code> 被调用了。CSS 类 loading 被添加给 DOM 中的应用元素，以表明数据正在被检索, 随后在数据就绪时，被解决处理器删除。</p>
<p>以上便是 <code>promise.all()</code> 的一些常见用例。如果一个 promise 被拒绝了，但是我们还想继续操作下去，又该怎么办呢？在这种情况下，<code>promise.allSettled()</code> 方法是更好的选择。</p>
<h2 id="3-2-Promise-allSettled-方法"><a href="#3-2-Promise-allSettled-方法" class="headerlink" title="3.2 Promise.allSettled() 方法"></a>3.2 Promise.allSettled() 方法</h2><p><code>Promise.allSettled()</code> 方法在 <code>Promise.all()</code> 方法的基础上做了细微的改变。该方法会等待 iterable 对象中所有的 Promise 都被解决，<strong>不管它们是被履行还是被拒绝</strong>。 <code>Promise.allSettled()</code> 返回的值<strong>总是一个处于履行状态</strong>的 Promise，它带有一个结果对象数组。</p>
<p>对于处于履行状态的 Promise 而言，其结果对象有两个属性：</p>
<ul>
<li><code>status</code>：该属性总是被设置为 <code>fulfilled</code> (履行)。</li>
<li><code>value</code>：这是该 Promise 被履行的值。</li>
</ul>
<p>对于处于拒绝状态的 Promise 而言，其结果对象也有两个属性：</p>
<ul>
<li><code>status</code>：该属性总是被设置为 <code>rejected</code> (拒绝)。</li>
<li><code>reason</code>：这是该 Promise 被拒绝的值。</li>
</ul>
<p>我们可以使用返回的对象数组来确定每个 Promise 的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results[<span class="number">0</span>].<span class="property">status</span>); <span class="comment">// &quot;fulfilled&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results[<span class="number">0</span>].<span class="property">value</span>); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results[<span class="number">1</span>].<span class="property">status</span>); <span class="comment">// &quot;rejected&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results[<span class="number">1</span>].<span class="property">reason</span>); <span class="comment">// 43</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results[<span class="number">2</span>].<span class="property">status</span>); <span class="comment">// &quot;fulfilled&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results[<span class="number">2</span>].<span class="property">value</span>); <span class="comment">// 44</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>尽管第二个 Promise 处于拒绝状态，但是对于 <code>Promise.allSettled()</code> 的调用仍然会返回一个处于履行状态的 Promise。</p>
<h3 id="3-1-1-何时使用-Promise-allSettled-方法"><a href="#3-1-1-何时使用-Promise-allSettled-方法" class="headerlink" title="3.1.1 何时使用 Promise.allSettled() 方法"></a>3.1.1 何时使用 Promise.allSettled() 方法</h3><p><code>Promise.allSettled()</code> 方法的许多用例和 <code>Promise.all()</code> 相同。不过它<strong>最适合用于忽略操作被拒绝、以不同方式处理拒绝或允许部分成功的情况。</strong>下面是一些常见的用例：</p>
<ol>
<li><strong>分别处理多个文件</strong></li>
</ol>
<p>在讨论 <code>Promise.all()</code> 时，我们看到了处理多个文件的例子。这些文件相互依赖，只有当所有文件都处理成功后，整个操作才能成功。在另一些情况下，我们分别处理多个文件。如果一个文件处理失败，那么我们无需停止整个操作，而是继续处理其他文件，同时记录处理失败的操作，以便之后重试.下面是一个在 node.js 中处理多个文件的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile, writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在文件上进行其他操作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transformText</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> text.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transformFiles</span>(<span class="params">filenames</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(</span><br><span class="line">    filenames.<span class="title function_">map</span>(<span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> <span class="title function_">transformText</span>(text))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">transformedText</span>) =&gt;</span> <span class="title function_">writeFile</span>(filename, transformedText))</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          reason.<span class="property">filename</span> = filename;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">transformFiles</span>([<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;file2.txt&#x27;</span>, <span class="string">&#x27;file3.txt&#x27;</span>]).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 得到失败的任务</span></span><br><span class="line">  <span class="keyword">const</span> failedTasks = results.<span class="title function_">filter</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (failedTasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Failed to transform <span class="subst">$&#123;failedTasks.length&#125;</span> files:`</span>);</span><br><span class="line">    failedTasks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`- <span class="subst">$&#123;task.reason.filename&#125;</span>: <span class="subst">$&#123;task.reason.message&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;All files transformed successfully.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码读取一系列文件，颠倒文件中的文本顺序，然后将这些文本写回原始文件。当然，你可以用其他任何操作来代替 <code>transformText()</code>, <code>transformFiles()</code> 函数接收一个由文件名组成的数组，读取文件的内容，转换文本，并将转换后的文本写回文件。链式 promise 体现了这个过程中的每一步。拒绝处理器，为拒绝理由添加了属性 filename, 以便事后更容易解释结果。当对所有文件的操作都完成后，我们对 results 进行过滤，找出转换失败的任务，然后将失败结果输出到控制台。在生产环境中，最好把失败结果送入一个监控系统或一个队列中，以便再次尝试转换。</p>
<ol start="2">
<li><strong>调用多个相互独立的 Web 服务 API</strong></li>
</ol>
<p>并且我们希望所有的请求都能成功。如果无需所有的请求都成功，那么我们可以使用 <code>Promise.allSettled()</code>。 回顾之前的例子，如果可以显示用户资料页面，即使有些数据丢失也没关系，那么我们就可以通过使用 <code>Promise.allSettled()</code> 来避免向用户显示错误消息。示例代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_BASE</span> = <span class="string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = [</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/posts`</span>,</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/albums`</span>,</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;API_BASE&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>/extras`</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> <span class="title function_">fetch</span>(url))).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> results.<span class="title function_">map</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result.<span class="property">value</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">responses</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">      response.<span class="title function_">map</span>(<span class="function">(<span class="params">resposne</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response?.<span class="property">ok</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [posts, albums, extras] = results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (posts) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Posts:&#x27;</span>, posts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (albums) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Albums:&#x27;</span>, albums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extras) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Extras:&#x27;</span>, extras);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to fetch user data:&#x27;</span>, reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子还调用了第三个端点，即：<code>$&#123;API_BASE&#125;/users/$&#123;userId&#125;/extras</code>, 因为这个端点并不存在，所以代码将返回 404。一旦所有请求都完成，履行处理器就会将每个结果映射到对应的 value 属性，这样做确保任何处于拒绝状态的 promise 都会被映射到 <strong>undefined</strong>，并且处于履行状态的 promise 被映射到从 <code>fetch()</code> 返回的响应对象。</p>
<p>首先，因为 response 可能是 undefined，所以我们需要在检查 OK 属性之前确定 response 是真值，然后读取每个有效响应的 JSON 主体，最后由旅行处理器读取数据。因为不能保证每个请求的数据都存在，所以我们需要在处理数据之前检查每个值是否存在。</p>
<ol start="3">
<li><strong>等候动画播放完成</strong></li>
</ol>
<p>在一个网页中，元素可以同时以多种方式实现动画化。比如我们可以使一个元素从网页的底部移动到顶部，同时改变该元素的宽度和高度，使其逐渐进入视野。在这种情况下，最好在对元素或网页进行下一步修改之前，等候所有的动画播放完成。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">waitForAnimations</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(</span><br><span class="line">    element.<span class="title function_">getAnimations</span>().<span class="title function_">map</span>(<span class="function">(<span class="params">animation</span>) =&gt;</span> animation.<span class="property">finished</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toastElementer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;toaster&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">waitFormAnimations</span>(toastElementer).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Toaster animations complete.&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们既不关心是否有任何动画播放失败，也不关心是否在动画播放过程中收到任何值。因此，<code>Promise.allSettled()</code> 比<code>Promise.all()</code> 更合适。<code>getAnimations()</code> 方法返回一个动画对象数组，其中每个对象都有一个<strong>包含 promise 的属性 finished</strong>。当动画播放完成时，这个 promise 就会进入解决状态，通过将每个 promise 传入 <code>Promise.allSettled()</code>, 我们将在所有动画都播放完成时得到通知。因为 <code>Promise.allSettled()</code> <strong>永远不会返回处于拒绝状态的 promise</strong>，所以我们可以直接附加一个履行处理器，而不用担心漏掉任何未捕获的拒绝错误。</p>
<h2 id="3-3-Promise-any-方法"><a href="#3-3-Promise-any-方法" class="headerlink" title="3.3 Promise.any() 方法"></a>3.3 Promise.any() 方法</h2><p><code>Promise.any()</code> 方法接收一个包含多个 promise 的 iterable 对象，并在传入的任何 promise 被<strong>履行</strong>时返回一个处于履行状态的 promise。<strong>一旦其中一个 promise 被履行，该操作就会提前完成</strong>，（这一点与<code>Promise.all()</code>相反，在<code>Promise.all()</code> 中，一旦有一个 promise 被拒绝，操作就会提前完成。）下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">any</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，尽管第一个 promise 被拒绝了，但对 <code>Promise.any()</code> 调用还是成功了。因为第二个 promise 被成功履行，第三个 promise 的结果则被忽略。</p>
<p>如果传递给 <code>Promise.any()</code> 的所有 promise 都被拒绝，那么 <code>Promise.any()</code> 将返回一个处于拒绝状态的 promise, 并且拒绝的理由是 AggregateError, AggregateError 是一个 错误，它代表了存储在属性 errors 中的多个错误。举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">44</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">45</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">any</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">message</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">errors</span>[<span class="number">0</span>]); <span class="comment">// 43</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">errors</span>[<span class="number">1</span>]); <span class="comment">// 44</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">errors</span>[<span class="number">2</span>]); <span class="comment">// 45</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里 <code>Promise.any()</code> 收到的 promise 都没有被履行，因此返回的 promise 以 AggregateError 为由被拒绝。可以检查属性 errors，它是一个数组，可用来检索每个 promise 的拒绝值。</p>
<h3 id="3-3-1-何时使用-Promise-any-方法"><a href="#3-3-1-何时使用-Promise-any-方法" class="headerlink" title="3.3.1 何时使用 Promise.any() 方法"></a>3.3.1 何时使用 Promise.any() 方法</h3><p><code>Promise.any()</code> 方法最适合这样的情况。我们希望传入的任何一个 promise 被成功履行即可，而不关心有多少其他 promise 被拒绝，除非他们都被拒绝。下面介绍一些常见用例：</p>
<ol>
<li><strong>执行对冲请求</strong></li>
</ol>
<p><strong>对冲请求</strong>是指客户端向多台服务器发出请求，并接受第一个回复的响应。这在客户端需要最小化延迟，且有服务器资源，专门用于管理额外负载和重复响应的情况下，很有用。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">HOSTS</span> = [<span class="string">&#x27;api1.example-url&#x27;</span>, <span class="string">&#x27;api2.example-url&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hedgedFetch</span>(<span class="params">endpoint</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(</span><br><span class="line">    <span class="variable constant_">HOSTS</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">hostname</span>) =&gt;</span> <span class="title function_">fetch</span>(<span class="string">`https://<span class="subst">$&#123;hostname&#125;</span><span class="subst">$&#123;endpoint&#125;</span>`</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hedgedFetch</span>(<span class="string">&#x27;/transactions&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>每个对冲请求都会调用一个主机数组 <code>hedgedFetch()</code>函数。根据这些主机名，创建一个 <code>fetch()</code> 请求数组，并将该数组传递给 <code>Promise.any()</code>, 即使实际上有多个请求，但在用户看来也只有一个请求。这样一来，用户只用使用一个履行处理器和一个拒绝处理器即可处理操作结果。就算有一个请求失败了，用户也不会知道，只有当所有请求都失败时，javascript 才会调用拒绝处理器。</p>
<ol start="2">
<li><strong>在 service worker 中使用最快速的响应</strong></li>
</ol>
<p>使用 service worker 的网页通常可以选择是从网络还是从缓存中加载数据。在某些情况下，网络请求可能比从缓存中加载更快。因此我们可能想使用 <code>Promise.any()</code> 来选择更快的响应。下面这段代码说明了 service worker 是如何工作的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取缓存响应</span></span><br><span class="line">  <span class="keyword">const</span> cachedResponse = caches.<span class="title function_">match</span>(event.<span class="property">request</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取新的响应</span></span><br><span class="line">  <span class="keyword">const</span> fetchedResponse = <span class="title function_">fetch</span>(event.<span class="property">request</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以最佳方案响应</span></span><br><span class="line">  event</span><br><span class="line">    .<span class="title function_">respondWith</span>(</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">any</span>([cachedResponse, fetchedResponse.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> cachedResponse)])</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      response ?? fetchedResponse; <span class="comment">// 选择最佳响应</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 fetch 事件监听器，我们可以监听网络请求并拦截响应。 这个关于 service work 的例子使用 fetch 事件监听器从缓存（使用<code>caches.match()</code>）和网络中（使用 <code>fetch()</code>）读取数据，<strong>对<code>caches.match()</code>的调用总是返回一个处于履行状态的 promise</strong>。其结果要么是匹配的响应对象，要么是 undefined（如果请求不再缓存中）。<code>event.respondWith()</code> 方法，需要传递一个 promise, 因此，这个事件处理器传递了 <code>Promise.any()</code> 的结果。</p>
<p><code>Promise.any()</code> 接收两个 promise, 一个是获取的响应，它带有拒绝处理器的，并且该拒绝处理器默认返回来自缓存的响应，另一个是缓存的响应本身。通过这种方式，如果缓存中存在满足要求的数据或者获取网络请求被拒绝，则 javascript 都将返回来自缓存的响应。然后履行处理器需要确保收到的响应是有效的。（请注意，如果缓存首先响应但未命中，则 response 可能为 undefined）。拒绝处理器不执行任何操作，因为在这种情况下，没有备选方案，由于获取的响应和缓存的响应都被拒绝，因此 javascript 会悄悄的忽略错误，以允许浏览器采取默认行为。</p>
<p>虽然 <code>Promise.any()</code> 在第一个成功履行的 promise 出现后就会提前完成，但我们也可以根据<strong>第一个已解决（可以是履行也可以是拒绝）的 promise</strong>来提前完成整个操作。而不管结果如何，对于这种情况，我们可以使用 <code>Promise.race()</code>。</p>
<h2 id="3-4-Promise-race-方法"><a href="#3-4-Promise-race-方法" class="headerlink" title="3.4 Promise.race() 方法"></a>3.4 Promise.race() 方法</h2><p>在监控多个 promise 时，<code>Promise.race()</code>方法与 <code>Promise.any()</code> 方法略有不同，这个方法也接受一个包含多个 promise 的 iterable 对象并返回一个 promise。但返回的 promise 在第一个 promise <strong>确定状态</strong> 就立即确定其状态。<code>Promise.race()</code>不像 <code>Promise.all()</code> 那样等待所有 promise 都<strong>被履行</strong>，也不像 <code>Promise.any()</code> 那样在<strong>第一个</strong> promise 被履行时即提前完成，而是一旦数组中的任何 promised 状态确定（不管成功还是失败都叫做状态已确定），就会返回一个 promise。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">43</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，第一个 promise 处于履行状态，其他 promise 则对应之后要执行的任务。随后 promise4 的履行处理器的调用，其值为 42，而其他 promise 被忽略，传递递给 <code>Promise.race()</code> 的 promise, <strong>互相竞争,看哪个先确定状态</strong>，如果首先确定状态的 promise 是履行状态，那么返回的 promise 也将处于履行状态，如果首先确定状态的 promise 是拒绝状态，那么返回的 promise 也将处于拒绝状态。以拒绝状态为例，我们来看一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">43</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">44</span>);</span><br><span class="line">  &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3]);</span><br><span class="line"></span><br><span class="line">promise4.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason); <span class="comment">// 43</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，promise1 和 promise3 都使用 <code>setTimeout()</code> 来延迟履行时间，结果是 promise4 被拒绝。因为 promise2 在 promise1 或 promise3 被解决之前就被拒绝了。尽管 promise1 和 promise3 最终都成功履行，但他们仍被忽略。因履行状态在 promise2 被拒绝之后才确定。</p>
<h3 id="3-4-1-何时使用-Promise-race-方法"><a href="#3-4-1-何时使用-Promise-race-方法" class="headerlink" title="3.4.1 何时使用 Promise.race() 方法"></a>3.4.1 何时使用 Promise.race() 方法</h3><p>如果我们希望能够提前完成涉及多个 promise 的操作，那么 <code>Promise.race()</code> 方法是最佳选择。在使用 <code>Promise.any()</code> 时，我们希望其中一个 promise 成功，并且仅在所有 promise 都失败时才给予关注。与此不同，在使用<code>Promise.race()</code> 时，即使一个 promise 失败，只要他在任何其他 promise 成功之前失败，我们也希望得知这个情况。下面介绍 <code>Promise.race()</code> 的常见用例：</p>
<ol>
<li><strong>为操作设置超时</strong></li>
</ol>
<p>虽然 <code>fetch()</code> 函数有很多有用的功能，但它无法为一个给定的请求管理超时(timeout)，一个请求会处于挂起状态，直到该请求以某种方式完成。我们可以通过使用 <code>Promise.race()</code> 来轻松的创建一个封装方法，为任何请求添加超时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">millseconds</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Timeout&#x27;</span>));</span><br><span class="line">    &#125;, millseconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchWithTimeout</span>(<span class="params">url, timeoutMs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">fetch</span>(url), <span class="title function_">timeout</span>(timeoutMs)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_URL</span> = <span class="string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchWithTimeout</span>(<span class="variable constant_">API_URL</span>, <span class="number">5000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(users);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>timeout()</code> 函数和我们之前创建的 <code>delay()</code> 函数类似， 只不过它在延迟后调用 <code>reject()</code>, (delay 函数则是调用 <code>resolve()</code>)。在这种情况下，延迟表示发生了错误。因为我们想在某请求所花的时间超预期时被告知。 <code>fetchWithTimeout()</code> 函数随后在一个数组中调用 <code>fetch()</code> 和 <code>timeout()</code> 并将其传递给了 <code>Promise.race()</code>。如果对 <code>fetch()</code> 的调用所花的时间超过了 <code>timeout()</code> 所规定的时间，返回的 promise 就会被拒绝，以便我们进行适当的处理。</p>
<blockquote>
<p>‼️ 请记住，即使 <code>fetchWithTimeout()</code> 拒绝了一个超过指定时间的请求，<strong>该请求也不会被取消，它将继续在后台等待响应</strong>，即使该响应应该被忽略。</p>
</blockquote>
<h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p>如果想同时监控和响应多个 promise, 那么我们可以采用 javascript 提供的多种方法，每种方法略有不同，但都让我们能够并行的运行多个 promise，并将它们作为一个整体来响应。</p>
<ul>
<li><p><strong>Promise.all()</strong>: 当且仅当所有 promise 都被履行时，返回的 promise 才会处于履行状态。若任何一个 promise 被拒绝，则返回的 promise 就处于拒绝状态的。</p>
</li>
<li><p><strong>Promise.allSettled()</strong>: 返回的 Promise 总是处于履行状态，并且带有一个结果对象数组。</p>
</li>
<li><p><strong>Promise.any()</strong>: 一旦有一个 promise 被履行，返回的 promise 就处于履行状态。而当所有的 promise 都被拒绝时，返回的 promise 就处于拒绝状态。</p>
</li>
<li><p><strong>Promise.race()</strong>: 返回的 promise 总是处于第一个被确定状态的 promise 的状态。如果首先确定状态的 promise 是进入履行状态，那么返回的 promise 也将处于旅行状态。如果首先确定状态的 promise 是进入拒绝状态，那么返回的 promise 也将处于拒绝状态。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>全面理解 Promise 系列（四)：异步函数和 await 表达式</title>
    <url>/2022/04/24/promise/series-04/</url>
    <content><![CDATA[<p>JavaScript 的设计初衷是作为底层工具在幕后提供高级语言特性使用。异步函数便是这样的高级语言特性，它让使用 promise 编程更接近于不使用 promise 编程。与其担心如何追踪 promise 及各种处理器，我们不如用异步函数将 promise 抽象化的。这样做的结果是使代码遵循我们所熟悉的自上而下的运行顺序。在讨论异步函数的原理细节之前，我们首先应当了解如何定义它。</p>
<h2 id="4-1-定义异步函数"><a href="#4-1-定义异步函数" class="headerlink" title="4.1 定义异步函数"></a>4.1 定义异步函数</h2><p>异步函数可以在任何原本使用同步函数的场合中使用。在大多数情况下，我们只需要在函数定义或方法定义之前添加 <strong>async</strong> 关键字，即可使其成为异步函数或异步方法。下面是一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomething</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomething</span> = <span class="keyword">async</span> (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步对象方法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步类方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async 关键字表示，紧跟其后的函数或方法应该是异步的。对 javascript 引擎来说，提前知道一个函数是否为异步函数很重要，因为异步函数的表现与同步函数不同。</p>
<h2 id="4-2-异步函数的不同之处"><a href="#4-2-异步函数的不同之处" class="headerlink" title="4.2 异步函数的不同之处"></a>4.2 异步函数的不同之处</h2><p>异步函数与同步函数的差异异体现在以下四个方面：</p>
<ul>
<li>返回值总是一个 promise；</li>
<li>抛出的错误是处于拒绝状态的 promise；</li>
<li>可以使用 await 表达式；</li>
<li>可以使用 for-await-of 循环。</li>
</ul>
<h3 id="4-2-1-返回值总是一个-Promise"><a href="#4-2-1-返回值总是一个-Promise" class="headerlink" title="4.2.1 返回值总是一个 Promise"></a>4.2.1 返回值总是一个 Promise</h3><p>与在同步函数中相同，我们可以在异步函数中使用 return 操作符。不同的是，无论我们用 return 指定什么类型的值异步函数，都<strong>总是返回一个 promise</strong>。 举例来说，如果返回一个数，那么这个数会被包裹在一个 promise 中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getNumber</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> result === <span class="string">&#x27;number&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">result.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，异步函数 <code>getNumber()</code> 返回了 42，但返回值实际上是一个处于履行状态的 promise。我们可以附加一个履行处理器来检索该值。实际上，<strong>异步函数会在后台调用<code>promise.resolve()</code>, 以确保总是返回一个 promise</strong>。如果在异步函数中向 return 传递一个 promise, 那么<strong>该 promise 不会被直接传递。相反，它的状态和值将被复制给一个新的 promise 并返回</strong>。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">doSomething</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result === promise); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">result.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>result 不是原 Promise</strong>，但它的内部状态与原 Promise 相同。因此，它的值仍然是 42。</p>
<p><strong>如果我们没有为一个异步函数指定返回值，那么它就会返回一个 Promise，并且其值为 undefined。</strong> 举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 没有返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">doSomething</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">result.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>无论我们用异步函数做什么，它都都会返回一个 Promsie。<strong>即便有错误被抛出，情况也是如此。</strong></p>
<h3 id="4-2-2-抛出的错误是处于拒绝状态的-Promise"><a href="#4-2-2-抛出的错误是处于拒绝状态的-Promise" class="headerlink" title="4.2.2 抛出的错误是处于拒绝状态的 Promise"></a>4.2.2 抛出的错误是处于拒绝状态的 Promise</h3><p>当异步函数发生错误时，它会返回一个处于拒绝状态的 Promise，<strong>而不是在函数外抛出错误。这意味着我们不能通过 <code>try-catch</code> 来捕获函数中的错误。</strong>举例来说，下面的代码不会捕获到错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something wrong!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">throwError</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Didn&#x27;t catch error&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error); <span class="comment">// 永远不会被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>throwError()</code> 函数会抛出一个错误，但是<code>try-catch</code> 没有捕获到这个错误，这是因为 <code>throwError()</code> 返回的是一个处于拒绝状态的 Promise。而不是在函数外面（try 块里）抛出错误。为了捕获这个错误，我们需要使用拒绝处理器，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something wrong!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">throwError</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error); <span class="comment">// Something wrong!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，拒绝处理器是用 <code>catch()</code> 分配的，结果向控制台输出错误消息。JavaScript 引擎花了很大力气来确保异步函数总是返回 Promise。这样一来我们就可以用统一的方法处理返回值。这又引入了异步函数不同于同步函数的第三个方面：可以使用 await 表达式。</p>
<h3 id="4-2-3-可以使用-await-表达式"><a href="#4-2-3-可以使用-await-表达式" class="headerlink" title="4.2.3 可以使用 await 表达式"></a>4.2.3 可以使用 await 表达式</h3><p>await 表达式的设计初衷是使 Promise 的应用变得简单。<strong>在 await 表达式中使用任何 Promise 都不需要手动分配履行处理器和拒绝处理器</strong>，而更像是同步函数中的代码：await 表达式会暂停函数的执行，直到 Promise 被履行或被拒绝。在履行时返回 Promise 履行后的结果值，在拒绝的时候<strong>抛出 Promise 被拒绝后的结果值</strong>。这让我们能够轻松的将 await 表达式的结果值赋给某个变量，并使用 <code>try-catch</code> 语句捕获拒绝值。下面是一个使用 <code>fetch()</code> API 但不使用 await 表达式的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">receiveJsonData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">`Unexpected status code: <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>receiveJsonData()</code> 函数返回一个 Promise。 该 Promise 的结果为 response 中的 JSON 数据。另有一个用于输出错误消息的拒绝处理器。下面展示如何把这个函数改写成使用 await 表达式的异步函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">      <span class="string">`Unexpected status code: <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个重写的版本中，对 <code>await fetch(url)</code> 的调用返回的 Promise 定义了履行处理器和拒绝处理器。变量 response 被赋予该 Promise 履行后的结果值（如果成功的话），而如果 Promise 被拒绝，则会抛出错误，并由 <code>try-catch</code> 语句捕获。<code>fetch(url)</code> 仍旧会返回一个结果为 JSON 数据的 Promise，但它是通过返回 <code>response.json()</code> （另一个 Promise）履行后的结果值来实现的。如果 <code>response.json()</code> 也被拒绝，那么 <code>await response.json()</code> 表达式也会抛出错误，并由 <code>catch</code> 语句捕获。</p>
<blockquote>
<p>🤔 你可能会有这样的疑问：如果返回的是一个 Promise， 那么为什么不直接返回 <code>response.json()</code> 而非要使用 <code>await</code> 表达式呢？来看下面的例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">receiveJsonData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">`Unexpected status code: <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子和之前的例子只有一个区别，就是 <code>return await response.json()</code> 和 <code>return response.json()</code>。 因为 <code>response.json()</code> 是一个 Promise，如果这个 Promise 被拒绝，使用 await 表达式会抛出错误，而不使用 await 表达式的话这个被拒绝的 Promise 不会被当作错误抛出，因此也不会被 <code>catch</code> 捕获。要想捕获这个错误只能使用 <code>response.json()</code> 返回的 Promise 的拒绝处理器。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">receiveJsonData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>(); <span class="comment">// 注意这里不使用 await 表达式</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">`Unexpected status code: <span class="subst">$&#123;response.status&#125;</span> <span class="subst">$&#123;response.statusText&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">receiveJsonData</span>(<span class="string">&#x27;https://example.com/data.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomethingWith</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这两种情况各有用例。有时候我们想在异步函数内部捕获错误，又是我们想让错误在函数外部得到处理。</p>
<ol>
<li><strong>对非 Promise 值使用 await 表达式</strong></li>
</ol>
<p>我们可以对非 promise 使用 await 表达式，<strong>因为其结果值总是通过<code>Promise.resolve()</code> 传递</strong>。这意味着，若结果值为 promise, 那么该 promise 将被直接传递;若结果值为非 promise 的 thenable 对象，则该对象会被解析为 promise 后再被传递。而其他类型的值则会被包裹在 promise 中后再被传递。来看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码中的 <code>doSomething()</code> 函数返回一个处于履行状态的 promise, 其值为 42。我们可以像下面这样重写这个函数，从而在不用异步函数的情况下实现同样的功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>await 拥有处理非 Promise deferred 值的能力，这意味着，即使我们猜错了正在使用的值，也没有关系。</p>
<ol start="2">
<li><strong>对多个 Promise 使用 await 表达式</strong></li>
</ol>
<p>尽管偶尔一个表达式只对一个 promise 进行操作，但我们可以利用 promise 的内置方法来有效的对多个 promise 进行操作。举例来说，如果想等待一个数组中的每一个 promise 都成功履行，那么我们可以结合使用 <code>Promise.all()</code> 方法和 await 表达式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/data1.json&#x27;</span>),</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/data2.json&#x27;</span>),</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/data3.json&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中 await 被用于 <code>Promise.all()</code> 的结果，以使函数等待，直到所有 promise 都成功履行，或者其中一个被拒绝（被拒绝的话会有错误抛出）。在函数等待时，这三个 promise 可以自由的并行执行。下面是一个在 Node.js 中读取多个文件的例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFiles</span>(<span class="params">filenames</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fileContents = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    filenames.<span class="title function_">map</span>(<span class="function"><span class="params">filename</span> =&gt;</span> <span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  ])</span><br><span class="line">  <span class="keyword">return</span> fileContents.<span class="title function_">map</span>(<span class="function"><span class="params">fileContent</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(fileContent));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFiles</span>([<span class="string">&#x27;file1.json&#x27;</span>, <span class="string">&#x27;file2.json&#x27;</span>, <span class="string">&#x27;file3.json&#x27;</span>])</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function"><span class="params">fileContents</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 按需处理数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fileContents);</span><br><span class="line">  &#125;)</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>异步函数 <code>readFiles()</code> 使用 await 和 <code>Promise.all()</code> 来等待所有的文件读取完成。然后文件内容可以被解析为 JSON 数据，从而以最合适的格式返回数据。</p>
<blockquote>
<p>💡 当然，我们也可以将 await 和 <code>Promise.allSettled()</code>、 <code>Promise.any()</code>、 <code>Promise.race()</code> 或者其他任何返回 Promise 的函数结合使用。</p>
</blockquote>
<h3 id="4-2-4-可以使用-for-await-of-循环"><a href="#4-2-4-可以使用-for-await-of-循环" class="headerlink" title="4.2.4 可以使用 for-await-of 循环"></a>4.2.4 可以使用 for-await-of 循环</h3><p>另一个可以在异步函数中启用的特殊语法是 <code>for-await-of</code> 循环。它让我们能够从一个 iterable 对象中检索值。 iterable 对象具有 <code>Symbol.iterator</code> 方法，它返回一个迭代器，异步 iterable 对象具有 <code>Symbol.asyncIterator</code>方法，它也返回一个迭代器，且结果值总是一个 Promise。 <code>for-await-of</code> 循环首先对 iterable 对象返回的每一个值调用 <code>Promise.resolve()</code>，接着等待每个 Promise 确定状态，然后继续循环的下一次迭代。</p>
<p>Javascript 中最常用的 iterable 对象是数组，我们可以使用一个 promise 数组和一个 <code>for-await-of</code> 循环来依次处理每个 promise, 如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="title function_">await</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [promise1, promise2, promise3]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子按照顺序处理 promise1、promise2 和 promise3。尽管这些是已解决（状态已确定）的 promise, 但 <code>for-await-of</code> 循环也可以用于未解决的 promise。因为 <code>for-await-of</code> 循环总是对从 iterable 对象中获取的值调用 <code>Promise.resolve()</code>, 所以我们可以直接将它用于数组,如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="title function_">await</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，虽然数组中没有 Promise，但 <code>for-await-of</code> 循环依然可以正常工作。</p>
<p>在 Node.js 中最常用的异步 iterable 对象是 readStream 对象。readStream 对象被用来定期从一个数据可能不全的数据源中读取数据。对于网络请求，读取大文件或事件流, readStream 对象提供了便捷的途径。以下是一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readCompleteTextStream</span>(<span class="params">readableObj</span>) &#123;</span><br><span class="line">  readableObj.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="title function_">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> readableObj) &#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_">readCompleteTextStream</span>(stream)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>readCompleteTextStream()</code> 函数接受一个名为 readableOb 的 readStream 对象作为参数。为了读取文本文件，我们首先使用 <code>setEncoding()</code> 方法将编码设置为 ‘UTF8’，然后使用 <code>for-await-of</code> 循环遍历从 readableObj 读取的数据。如果文件内容较短，那么其中可能只有一个数据块, 如果文件内容较长，那么其中可能有多个数据块。使用 <code>for-await-of</code> 循环时，我们不必担心究竟有多少个数据块。<br>与 await 表达式类似，如果从异步对象返回的任何 promise 被拒绝，那么 <code>for-await-of</code> 循环会抛出一个错误。我们可以在异步函数内部用 <code>try-catch</code> 语句去捕获这个错误。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readCompleteTextStream</span>(<span class="params">readableObj</span>) &#123;</span><br><span class="line">  readableObj.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="title function_">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> readableObj) &#123;</span><br><span class="line">      data += chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;file.txt&#x27;</span>);</span><br><span class="line"><span class="title function_">readCompleteTextStream</span>(stream)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>for-await-of</code> 循环中的<strong>第一个被拒绝的 promise, 会导致错误抛出</strong>，<code>try-catch</code> 语句可以捕获这个错误，并将其记录到控制台中。如果没有 <code>try-catch</code> 语句，那么 <code>for-await-of</code> 循环中被拒绝的 promise 将作为<code>readCompleteTextStream()</code>函数中被拒绝的 promise 返回。</p>
<h2 id="4-3-顶层-await-表达式"><a href="#4-3-顶层-await-表达式" class="headerlink" title="4.3 顶层 await 表达式"></a>4.3 顶层 await 表达式</h2><p>我们可以在 javascript 的模块的顶层(位于异步函数之外)使用 await 表达式。<strong>从本质上讲，javascript 模块在默认情况下，就像包裹着整个模块的异步函数一样</strong>。这使得我们可以直接用调用基于 promise 函数，比如使用<code>await</code>imports()&#96;函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态倒入</span></span><br><span class="line"><span class="keyword">import</span> somthing <span class="keyword">from</span> <span class="string">&#x27;./file.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&#x27;./another-file.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> somethingElse = <span class="keyword">await</span> <span class="keyword">import</span>(filename);</span><br></pre></td></tr></table></figure>

<p>使用顶层 await 表达式，我们可以静态加载模块的同时动态加载模块。（动态加载的模块，允许我们动态的构建模块指定符，这在静态导入中是不可能实现的）。这个例子同时展示了静态导入和动态导入，以说明二者的区别。</p>
<p>当 javascript 的引擎遇到一个顶层 await 表达式时，<strong>javascript 模块会暂停执行</strong>，直到该 pr omise 被解决。如果被暂停的模块的父级模块有静态导入需要处理，那么即使在顶层使用 awit 表达式的同级模块被暂停时，这些静态导入也可以继续。在这种情况下，我们无法保证同级模块的加载顺序，但这个顺序往往并不重要。</p>
<blockquote>
<p>⚠️ 不能在 Javascript 脚本中使用顶层 await 表达式。为了使用顶层 await 表达式，我们必须使用 import 或<code>&lt;script type=&quot;module&quot;&gt;</code>标签来加载 javascript 代码。</p>
</blockquote>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><ul>
<li>异步函数让我们可以在无需手动分配履行处理器和拒绝处理器的情况下使用 promise。通过在函数定义之前添加 async 关键字。我们可以将任何函数变成异步函数。</li>
<li>异步函数的返回值总是一个 promise。如果你从异步函数中返回一个 promise, 那么它将被复制并返回到被调用的节点。如果你返回一个非 promise 值，那么该值将被解析为 promise，并返回到被调用的节点。</li>
<li>异步函数抛出的错误会被捕获，并<strong>作为处于拒绝状态的 promise 返回</strong>。正因为如此，我们无法使用 <code>try-catch</code> 语句来捕获源自异步函数的错误。相反，我们需要给返回的 promise 分配一个拒绝处理器。</li>
<li>异步函数有两种特殊的语法 await 表达式和 for-wait-of 循环。await 表达式用于为 promise 自动分配履行处理器和拒绝处理器，从而使履行值成为 awit 表达式返回的值，拒绝则会导致错误被抛出。for-await-of 循环用于异步 iterable 对象，并允许在循环中使用 promise。 for-await-of 循环等待从异步 iterable 对象返回的每个 Promise 确定状态，然后进入下一次迭代。如果一个来自异步 iterable 对象的 promise 被拒绝，那么就会有错误被抛出。</li>
<li>此外，我们还可以在 javascript 模块的顶层使用 await 的表达式。不过这个功能在 javascript 脚本中不可用。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
